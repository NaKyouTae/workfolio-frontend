// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "com.spectrum.workfolio.proto";

export interface Worker {
  id: string;
  nickName: string;
  phone: string;
  email: string;
  birthDate?: number | undefined;
  gender?: Worker_Gender | undefined;
  status: Worker_WorkerStatus;
  createdAt: number;
  updatedAt: number;
}

export enum Worker_Gender {
  UNKNOWN = 0,
  MALE = 1,
  FEMALE = 2,
  UNRECOGNIZED = -1,
}

export function worker_GenderFromJSON(object: any): Worker_Gender {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Worker_Gender.UNKNOWN;
    case 1:
    case "MALE":
      return Worker_Gender.MALE;
    case 2:
    case "FEMALE":
      return Worker_Gender.FEMALE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Worker_Gender.UNRECOGNIZED;
  }
}

export function worker_GenderToJSON(object: Worker_Gender): string {
  switch (object) {
    case Worker_Gender.UNKNOWN:
      return "UNKNOWN";
    case Worker_Gender.MALE:
      return "MALE";
    case Worker_Gender.FEMALE:
      return "FEMALE";
    case Worker_Gender.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Worker_WorkerStatus {
  WORKER_STATUS_UNKNOWN = 0,
  ACTIVE = 1,
  INACTIVE = 2,
  DELETED = 3,
  UNRECOGNIZED = -1,
}

export function worker_WorkerStatusFromJSON(object: any): Worker_WorkerStatus {
  switch (object) {
    case 0:
    case "WORKER_STATUS_UNKNOWN":
      return Worker_WorkerStatus.WORKER_STATUS_UNKNOWN;
    case 1:
    case "ACTIVE":
      return Worker_WorkerStatus.ACTIVE;
    case 2:
    case "INACTIVE":
      return Worker_WorkerStatus.INACTIVE;
    case 3:
    case "DELETED":
      return Worker_WorkerStatus.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Worker_WorkerStatus.UNRECOGNIZED;
  }
}

export function worker_WorkerStatusToJSON(object: Worker_WorkerStatus): string {
  switch (object) {
    case Worker_WorkerStatus.WORKER_STATUS_UNKNOWN:
      return "WORKER_STATUS_UNKNOWN";
    case Worker_WorkerStatus.ACTIVE:
      return "ACTIVE";
    case Worker_WorkerStatus.INACTIVE:
      return "INACTIVE";
    case Worker_WorkerStatus.DELETED:
      return "DELETED";
    case Worker_WorkerStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Account {
  id: string;
  type: Account_AccountType;
  providerId: string;
  email: string;
  worker?: Worker | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum Account_AccountType {
  UNKNOWN = 0,
  UNSPECIFIED = 1,
  BASIC = 2,
  PREMIUM = 3,
  UNRECOGNIZED = -1,
}

export function account_AccountTypeFromJSON(object: any): Account_AccountType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Account_AccountType.UNKNOWN;
    case 1:
    case "UNSPECIFIED":
      return Account_AccountType.UNSPECIFIED;
    case 2:
    case "BASIC":
      return Account_AccountType.BASIC;
    case 3:
    case "PREMIUM":
      return Account_AccountType.PREMIUM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Account_AccountType.UNRECOGNIZED;
  }
}

export function account_AccountTypeToJSON(object: Account_AccountType): string {
  switch (object) {
    case Account_AccountType.UNKNOWN:
      return "UNKNOWN";
    case Account_AccountType.UNSPECIFIED:
      return "UNSPECIFIED";
    case Account_AccountType.BASIC:
      return "BASIC";
    case Account_AccountType.PREMIUM:
      return "PREMIUM";
    case Account_AccountType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Resume {
  id: string;
  title: string;
  name: string;
  phone: string;
  email: string;
  birthDate?: number | undefined;
  gender?: Resume_Gender | undefined;
  position: string;
  isPublic?: boolean | undefined;
  isDefault?: boolean | undefined;
  description: string;
  worker?: Worker | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum Resume_Gender {
  UNKNOWN = 0,
  MALE = 1,
  FEMALE = 2,
  UNRECOGNIZED = -1,
}

export function resume_GenderFromJSON(object: any): Resume_Gender {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Resume_Gender.UNKNOWN;
    case 1:
    case "MALE":
      return Resume_Gender.MALE;
    case 2:
    case "FEMALE":
      return Resume_Gender.FEMALE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Resume_Gender.UNRECOGNIZED;
  }
}

export function resume_GenderToJSON(object: Resume_Gender): string {
  switch (object) {
    case Resume_Gender.UNKNOWN:
      return "UNKNOWN";
    case Resume_Gender.MALE:
      return "MALE";
    case Resume_Gender.FEMALE:
      return "FEMALE";
    case Resume_Gender.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ResumeDetail {
  id: string;
  title: string;
  name: string;
  phone: string;
  email: string;
  birthDate?: number | undefined;
  gender?: Resume_Gender | undefined;
  position: string;
  isPublic?: boolean | undefined;
  isDefault?: boolean | undefined;
  publicId: string;
  description: string;
  worker?: Worker | undefined;
  careers: Career[];
  educations: Education[];
  activities: Activity[];
  projects: Project[];
  languageSkills: LanguageSkill[];
  attachments: Attachment[];
  createdAt: number;
  updatedAt: number;
}

export interface Career {
  id: string;
  name: string;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  isWorking?: boolean | undefined;
  position: string;
  employmentType?: Career_EmploymentType | undefined;
  department: string;
  jobTitle: string;
  rank: string;
  salary: number;
  description: string;
  isVisible: boolean;
  priority: number;
  resume?: Resume | undefined;
  salaries: Salary[];
  createdAt: number;
  updatedAt: number;
}

export enum Career_EmploymentType {
  UNKNOWN = 0,
  FULL_TIME = 1,
  CONTRACT = 2,
  INTERN = 3,
  FREELANCER = 4,
  UNRECOGNIZED = -1,
}

export function career_EmploymentTypeFromJSON(object: any): Career_EmploymentType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Career_EmploymentType.UNKNOWN;
    case 1:
    case "FULL_TIME":
      return Career_EmploymentType.FULL_TIME;
    case 2:
    case "CONTRACT":
      return Career_EmploymentType.CONTRACT;
    case 3:
    case "INTERN":
      return Career_EmploymentType.INTERN;
    case 4:
    case "FREELANCER":
      return Career_EmploymentType.FREELANCER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Career_EmploymentType.UNRECOGNIZED;
  }
}

export function career_EmploymentTypeToJSON(object: Career_EmploymentType): string {
  switch (object) {
    case Career_EmploymentType.UNKNOWN:
      return "UNKNOWN";
    case Career_EmploymentType.FULL_TIME:
      return "FULL_TIME";
    case Career_EmploymentType.CONTRACT:
      return "CONTRACT";
    case Career_EmploymentType.INTERN:
      return "INTERN";
    case Career_EmploymentType.FREELANCER:
      return "FREELANCER";
    case Career_EmploymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Salary {
  id: string;
  amount: number;
  memo: string;
  negotiationDate?: number | undefined;
  isVisible: boolean;
  priority: number;
  career?: Career | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface Education {
  id: string;
  major: string;
  name: string;
  description: string;
  status?: Education_EducationStatus | undefined;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  isVisible: boolean;
  priority: number;
  resume?: Resume | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum Education_EducationStatus {
  UNKNOWN = 0,
  GRADUATED = 1,
  GRADUATING = 2,
  ENROLLED = 3,
  DROPPED_OUT = 4,
  COMPLETED = 5,
  ON_LEAVE = 6,
  UNRECOGNIZED = -1,
}

export function education_EducationStatusFromJSON(object: any): Education_EducationStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Education_EducationStatus.UNKNOWN;
    case 1:
    case "GRADUATED":
      return Education_EducationStatus.GRADUATED;
    case 2:
    case "GRADUATING":
      return Education_EducationStatus.GRADUATING;
    case 3:
    case "ENROLLED":
      return Education_EducationStatus.ENROLLED;
    case 4:
    case "DROPPED_OUT":
      return Education_EducationStatus.DROPPED_OUT;
    case 5:
    case "COMPLETED":
      return Education_EducationStatus.COMPLETED;
    case 6:
    case "ON_LEAVE":
      return Education_EducationStatus.ON_LEAVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Education_EducationStatus.UNRECOGNIZED;
  }
}

export function education_EducationStatusToJSON(object: Education_EducationStatus): string {
  switch (object) {
    case Education_EducationStatus.UNKNOWN:
      return "UNKNOWN";
    case Education_EducationStatus.GRADUATED:
      return "GRADUATED";
    case Education_EducationStatus.GRADUATING:
      return "GRADUATING";
    case Education_EducationStatus.ENROLLED:
      return "ENROLLED";
    case Education_EducationStatus.DROPPED_OUT:
      return "DROPPED_OUT";
    case Education_EducationStatus.COMPLETED:
      return "COMPLETED";
    case Education_EducationStatus.ON_LEAVE:
      return "ON_LEAVE";
    case Education_EducationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Activity {
  id: string;
  type?: Activity_ActivityType | undefined;
  name: string;
  organization: string;
  certificateNumber: string;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  description: string;
  isVisible: boolean;
  priority: number;
  resume?: Resume | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum Activity_ActivityType {
  UNKNOWN = 0,
  EXTERNAL = 1,
  EDUCATION = 2,
  CERTIFICATION = 3,
  AWARD = 4,
  COMPETITION = 5,
  ETC = 6,
  UNRECOGNIZED = -1,
}

export function activity_ActivityTypeFromJSON(object: any): Activity_ActivityType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Activity_ActivityType.UNKNOWN;
    case 1:
    case "EXTERNAL":
      return Activity_ActivityType.EXTERNAL;
    case 2:
    case "EDUCATION":
      return Activity_ActivityType.EDUCATION;
    case 3:
    case "CERTIFICATION":
      return Activity_ActivityType.CERTIFICATION;
    case 4:
    case "AWARD":
      return Activity_ActivityType.AWARD;
    case 5:
    case "COMPETITION":
      return Activity_ActivityType.COMPETITION;
    case 6:
    case "ETC":
      return Activity_ActivityType.ETC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Activity_ActivityType.UNRECOGNIZED;
  }
}

export function activity_ActivityTypeToJSON(object: Activity_ActivityType): string {
  switch (object) {
    case Activity_ActivityType.UNKNOWN:
      return "UNKNOWN";
    case Activity_ActivityType.EXTERNAL:
      return "EXTERNAL";
    case Activity_ActivityType.EDUCATION:
      return "EDUCATION";
    case Activity_ActivityType.CERTIFICATION:
      return "CERTIFICATION";
    case Activity_ActivityType.AWARD:
      return "AWARD";
    case Activity_ActivityType.COMPETITION:
      return "COMPETITION";
    case Activity_ActivityType.ETC:
      return "ETC";
    case Activity_ActivityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Project {
  id: string;
  title: string;
  affiliation: string;
  role: string;
  description: string;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  isVisible: boolean;
  priority: number;
  resume?: Resume | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface LanguageSkill {
  id: string;
  language?: LanguageSkill_Language | undefined;
  level?: LanguageSkill_LanguageLevel | undefined;
  isVisible: boolean;
  priority: number;
  resume?: Resume | undefined;
  languageTests: LanguageTest[];
  createdAt: number;
  updatedAt: number;
}

export enum LanguageSkill_Language {
  LANGUAGE_UNKNOWN = 0,
  ENGLISH = 1,
  JAPANESE = 2,
  CHINESE = 3,
  KOREAN = 4,
  FRENCH = 5,
  SPANISH = 6,
  GERMAN = 7,
  RUSSIAN = 8,
  VIETNAMESE = 9,
  ITALIAN = 10,
  THAI = 11,
  ARABIC = 12,
  PORTUGUESE = 13,
  INDONESIAN = 14,
  MONGOLIAN = 15,
  TURKISH = 16,
  UNRECOGNIZED = -1,
}

export function languageSkill_LanguageFromJSON(object: any): LanguageSkill_Language {
  switch (object) {
    case 0:
    case "LANGUAGE_UNKNOWN":
      return LanguageSkill_Language.LANGUAGE_UNKNOWN;
    case 1:
    case "ENGLISH":
      return LanguageSkill_Language.ENGLISH;
    case 2:
    case "JAPANESE":
      return LanguageSkill_Language.JAPANESE;
    case 3:
    case "CHINESE":
      return LanguageSkill_Language.CHINESE;
    case 4:
    case "KOREAN":
      return LanguageSkill_Language.KOREAN;
    case 5:
    case "FRENCH":
      return LanguageSkill_Language.FRENCH;
    case 6:
    case "SPANISH":
      return LanguageSkill_Language.SPANISH;
    case 7:
    case "GERMAN":
      return LanguageSkill_Language.GERMAN;
    case 8:
    case "RUSSIAN":
      return LanguageSkill_Language.RUSSIAN;
    case 9:
    case "VIETNAMESE":
      return LanguageSkill_Language.VIETNAMESE;
    case 10:
    case "ITALIAN":
      return LanguageSkill_Language.ITALIAN;
    case 11:
    case "THAI":
      return LanguageSkill_Language.THAI;
    case 12:
    case "ARABIC":
      return LanguageSkill_Language.ARABIC;
    case 13:
    case "PORTUGUESE":
      return LanguageSkill_Language.PORTUGUESE;
    case 14:
    case "INDONESIAN":
      return LanguageSkill_Language.INDONESIAN;
    case 15:
    case "MONGOLIAN":
      return LanguageSkill_Language.MONGOLIAN;
    case 16:
    case "TURKISH":
      return LanguageSkill_Language.TURKISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LanguageSkill_Language.UNRECOGNIZED;
  }
}

export function languageSkill_LanguageToJSON(object: LanguageSkill_Language): string {
  switch (object) {
    case LanguageSkill_Language.LANGUAGE_UNKNOWN:
      return "LANGUAGE_UNKNOWN";
    case LanguageSkill_Language.ENGLISH:
      return "ENGLISH";
    case LanguageSkill_Language.JAPANESE:
      return "JAPANESE";
    case LanguageSkill_Language.CHINESE:
      return "CHINESE";
    case LanguageSkill_Language.KOREAN:
      return "KOREAN";
    case LanguageSkill_Language.FRENCH:
      return "FRENCH";
    case LanguageSkill_Language.SPANISH:
      return "SPANISH";
    case LanguageSkill_Language.GERMAN:
      return "GERMAN";
    case LanguageSkill_Language.RUSSIAN:
      return "RUSSIAN";
    case LanguageSkill_Language.VIETNAMESE:
      return "VIETNAMESE";
    case LanguageSkill_Language.ITALIAN:
      return "ITALIAN";
    case LanguageSkill_Language.THAI:
      return "THAI";
    case LanguageSkill_Language.ARABIC:
      return "ARABIC";
    case LanguageSkill_Language.PORTUGUESE:
      return "PORTUGUESE";
    case LanguageSkill_Language.INDONESIAN:
      return "INDONESIAN";
    case LanguageSkill_Language.MONGOLIAN:
      return "MONGOLIAN";
    case LanguageSkill_Language.TURKISH:
      return "TURKISH";
    case LanguageSkill_Language.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LanguageSkill_LanguageLevel {
  LANGUAGE_LEVEL_UNKNOWN = 0,
  DAILY_CONVERSATION = 1,
  BUSINESS_CONVERSATION = 2,
  NATIVE_LEVEL = 3,
  UNRECOGNIZED = -1,
}

export function languageSkill_LanguageLevelFromJSON(object: any): LanguageSkill_LanguageLevel {
  switch (object) {
    case 0:
    case "LANGUAGE_LEVEL_UNKNOWN":
      return LanguageSkill_LanguageLevel.LANGUAGE_LEVEL_UNKNOWN;
    case 1:
    case "DAILY_CONVERSATION":
      return LanguageSkill_LanguageLevel.DAILY_CONVERSATION;
    case 2:
    case "BUSINESS_CONVERSATION":
      return LanguageSkill_LanguageLevel.BUSINESS_CONVERSATION;
    case 3:
    case "NATIVE_LEVEL":
      return LanguageSkill_LanguageLevel.NATIVE_LEVEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LanguageSkill_LanguageLevel.UNRECOGNIZED;
  }
}

export function languageSkill_LanguageLevelToJSON(object: LanguageSkill_LanguageLevel): string {
  switch (object) {
    case LanguageSkill_LanguageLevel.LANGUAGE_LEVEL_UNKNOWN:
      return "LANGUAGE_LEVEL_UNKNOWN";
    case LanguageSkill_LanguageLevel.DAILY_CONVERSATION:
      return "DAILY_CONVERSATION";
    case LanguageSkill_LanguageLevel.BUSINESS_CONVERSATION:
      return "BUSINESS_CONVERSATION";
    case LanguageSkill_LanguageLevel.NATIVE_LEVEL:
      return "NATIVE_LEVEL";
    case LanguageSkill_LanguageLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LanguageTest {
  id: string;
  name: string;
  score: string;
  acquiredAt?: number | undefined;
  isVisible: boolean;
  priority: number;
  languageSkill?: LanguageSkill | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface Record {
  id: string;
  title: string;
  type: Record_RecordType;
  description: string;
  startedAt: number;
  endedAt: number;
  worker?: Worker | undefined;
  recordGroup?: RecordGroup | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum Record_RecordType {
  UNKNOWN = 0,
  TIME = 1,
  DAY = 2,
  MULTI_DAY = 3,
  UNRECOGNIZED = -1,
}

export function record_RecordTypeFromJSON(object: any): Record_RecordType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Record_RecordType.UNKNOWN;
    case 1:
    case "TIME":
      return Record_RecordType.TIME;
    case 2:
    case "DAY":
      return Record_RecordType.DAY;
    case 3:
    case "MULTI_DAY":
      return Record_RecordType.MULTI_DAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Record_RecordType.UNRECOGNIZED;
  }
}

export function record_RecordTypeToJSON(object: Record_RecordType): string {
  switch (object) {
    case Record_RecordType.UNKNOWN:
      return "UNKNOWN";
    case Record_RecordType.TIME:
      return "TIME";
    case Record_RecordType.DAY:
      return "DAY";
    case Record_RecordType.MULTI_DAY:
      return "MULTI_DAY";
    case Record_RecordType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RecordGroup {
  id: string;
  type: RecordGroup_RecordGroupType;
  title: string;
  isDefault: boolean;
  publicId: string;
  color: string;
  defaultRole: RecordGroup_RecordGroupRole;
  priority: number;
  worker?: Worker | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum RecordGroup_RecordGroupType {
  UNKNOWN = 0,
  PUBLIC = 1,
  PRIVATE = 2,
  SHARED = 3,
  UNRECOGNIZED = -1,
}

export function recordGroup_RecordGroupTypeFromJSON(object: any): RecordGroup_RecordGroupType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return RecordGroup_RecordGroupType.UNKNOWN;
    case 1:
    case "PUBLIC":
      return RecordGroup_RecordGroupType.PUBLIC;
    case 2:
    case "PRIVATE":
      return RecordGroup_RecordGroupType.PRIVATE;
    case 3:
    case "SHARED":
      return RecordGroup_RecordGroupType.SHARED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecordGroup_RecordGroupType.UNRECOGNIZED;
  }
}

export function recordGroup_RecordGroupTypeToJSON(object: RecordGroup_RecordGroupType): string {
  switch (object) {
    case RecordGroup_RecordGroupType.UNKNOWN:
      return "UNKNOWN";
    case RecordGroup_RecordGroupType.PUBLIC:
      return "PUBLIC";
    case RecordGroup_RecordGroupType.PRIVATE:
      return "PRIVATE";
    case RecordGroup_RecordGroupType.SHARED:
      return "SHARED";
    case RecordGroup_RecordGroupType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RecordGroup_RecordGroupRole {
  ROLE_UNKNOWN = 0,
  ADMIN = 1,
  FULL = 2,
  VIEW = 3,
  UNRECOGNIZED = -1,
}

export function recordGroup_RecordGroupRoleFromJSON(object: any): RecordGroup_RecordGroupRole {
  switch (object) {
    case 0:
    case "ROLE_UNKNOWN":
      return RecordGroup_RecordGroupRole.ROLE_UNKNOWN;
    case 1:
    case "ADMIN":
      return RecordGroup_RecordGroupRole.ADMIN;
    case 2:
    case "FULL":
      return RecordGroup_RecordGroupRole.FULL;
    case 3:
    case "VIEW":
      return RecordGroup_RecordGroupRole.VIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecordGroup_RecordGroupRole.UNRECOGNIZED;
  }
}

export function recordGroup_RecordGroupRoleToJSON(object: RecordGroup_RecordGroupRole): string {
  switch (object) {
    case RecordGroup_RecordGroupRole.ROLE_UNKNOWN:
      return "ROLE_UNKNOWN";
    case RecordGroup_RecordGroupRole.ADMIN:
      return "ADMIN";
    case RecordGroup_RecordGroupRole.FULL:
      return "FULL";
    case RecordGroup_RecordGroupRole.VIEW:
      return "VIEW";
    case RecordGroup_RecordGroupRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WorkerRecordGroup {
  id: string;
  publicId: string;
  role: WorkerRecordGroup_RecordGroupRole;
  priority: number;
  worker?: Worker | undefined;
  recordGroup?: RecordGroup | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum WorkerRecordGroup_RecordGroupRole {
  UNKNOWN = 0,
  ADMIN = 1,
  FULL = 2,
  VIEW = 3,
  UNRECOGNIZED = -1,
}

export function workerRecordGroup_RecordGroupRoleFromJSON(object: any): WorkerRecordGroup_RecordGroupRole {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return WorkerRecordGroup_RecordGroupRole.UNKNOWN;
    case 1:
    case "ADMIN":
      return WorkerRecordGroup_RecordGroupRole.ADMIN;
    case 2:
    case "FULL":
      return WorkerRecordGroup_RecordGroupRole.FULL;
    case 3:
    case "VIEW":
      return WorkerRecordGroup_RecordGroupRole.VIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkerRecordGroup_RecordGroupRole.UNRECOGNIZED;
  }
}

export function workerRecordGroup_RecordGroupRoleToJSON(object: WorkerRecordGroup_RecordGroupRole): string {
  switch (object) {
    case WorkerRecordGroup_RecordGroupRole.UNKNOWN:
      return "UNKNOWN";
    case WorkerRecordGroup_RecordGroupRole.ADMIN:
      return "ADMIN";
    case WorkerRecordGroup_RecordGroupRole.FULL:
      return "FULL";
    case WorkerRecordGroup_RecordGroupRole.VIEW:
      return "VIEW";
    case WorkerRecordGroup_RecordGroupRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SuccessResponse {
  isSuccess: boolean;
}

export interface SystemConfig {
  id: string;
  type: SystemConfig_SystemConfigType;
  value: string;
  worker?: Worker | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum SystemConfig_SystemConfigType {
  UNKNOWN = 0,
  DEFAULT_RECORD_TYPE = 1,
  UNRECOGNIZED = -1,
}

export function systemConfig_SystemConfigTypeFromJSON(object: any): SystemConfig_SystemConfigType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return SystemConfig_SystemConfigType.UNKNOWN;
    case 1:
    case "DEFAULT_RECORD_TYPE":
      return SystemConfig_SystemConfigType.DEFAULT_RECORD_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SystemConfig_SystemConfigType.UNRECOGNIZED;
  }
}

export function systemConfig_SystemConfigTypeToJSON(object: SystemConfig_SystemConfigType): string {
  switch (object) {
    case SystemConfig_SystemConfigType.UNKNOWN:
      return "UNKNOWN";
    case SystemConfig_SystemConfigType.DEFAULT_RECORD_TYPE:
      return "DEFAULT_RECORD_TYPE";
    case SystemConfig_SystemConfigType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TurnOver {
  id: string;
  name: string;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  worker?: Worker | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface TurnOverDetail {
  id: string;
  name: string;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  worker?: Worker | undefined;
  turnOverGoal?: TurnOverGoalDetail | undefined;
  turnOverChallenge?: TurnOverChallengeDetail | undefined;
  turnOverRetrospective?: TurnOverRetrospectiveDetail | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface TurnOverGoal {
  id: string;
  reason: string;
  goal: string;
  turnOver?: TurnOver | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface TurnOverGoalDetail {
  id: string;
  reason: string;
  goal: string;
  selfIntroductions: SelfIntroduction[];
  interviewQuestions: InterviewQuestion[];
  checkList: CheckList[];
  memos: Memo[];
  attachments: Attachment[];
  createdAt: number;
  updatedAt: number;
}

export interface SelfIntroduction {
  id: string;
  question: string;
  content: string;
  isVisible: boolean;
  priority: number;
  turnOver?: TurnOver | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface InterviewQuestion {
  id: string;
  question: string;
  answer: string;
  isVisible: boolean;
  priority: number;
  turnOver?: TurnOver | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface CheckList {
  id: string;
  checked: boolean;
  content: string;
  isVisible: boolean;
  priority: number;
  turnOver?: TurnOver | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface TurnOverChallenge {
  id: string;
  turnOver?: TurnOver | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface TurnOverChallengeDetail {
  id: string;
  jobApplications: JobApplicationDetail[];
  memos: Memo[];
  attachments: Attachment[];
  createdAt: number;
  updatedAt: number;
}

export interface JobApplication {
  id: string;
  name: string;
  position: string;
  jobPostingTitle: string;
  jobPostingUrl: string;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  applicationSource: string;
  memo: string;
  status: JobApplication_JobApplicationStatus;
  isVisible: boolean;
  priority: number;
  turnOver?: TurnOver | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum JobApplication_JobApplicationStatus {
  UNKNOWN = 0,
  PENDING = 1,
  RUNNING = 2,
  PASSED = 3,
  FAILED = 4,
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function jobApplication_JobApplicationStatusFromJSON(object: any): JobApplication_JobApplicationStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return JobApplication_JobApplicationStatus.UNKNOWN;
    case 1:
    case "PENDING":
      return JobApplication_JobApplicationStatus.PENDING;
    case 2:
    case "RUNNING":
      return JobApplication_JobApplicationStatus.RUNNING;
    case 3:
    case "PASSED":
      return JobApplication_JobApplicationStatus.PASSED;
    case 4:
    case "FAILED":
      return JobApplication_JobApplicationStatus.FAILED;
    case 5:
    case "CANCELLED":
      return JobApplication_JobApplicationStatus.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobApplication_JobApplicationStatus.UNRECOGNIZED;
  }
}

export function jobApplication_JobApplicationStatusToJSON(object: JobApplication_JobApplicationStatus): string {
  switch (object) {
    case JobApplication_JobApplicationStatus.UNKNOWN:
      return "UNKNOWN";
    case JobApplication_JobApplicationStatus.PENDING:
      return "PENDING";
    case JobApplication_JobApplicationStatus.RUNNING:
      return "RUNNING";
    case JobApplication_JobApplicationStatus.PASSED:
      return "PASSED";
    case JobApplication_JobApplicationStatus.FAILED:
      return "FAILED";
    case JobApplication_JobApplicationStatus.CANCELLED:
      return "CANCELLED";
    case JobApplication_JobApplicationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface JobApplicationDetail {
  id: string;
  name: string;
  position: string;
  jobPostingTitle: string;
  jobPostingUrl: string;
  startedAt?: number | undefined;
  endedAt?: number | undefined;
  applicationSource: string;
  memo: string;
  status: JobApplication_JobApplicationStatus;
  isVisible: boolean;
  priority: number;
  applicationStages: ApplicationStage[];
  createdAt: number;
  updatedAt: number;
}

export interface ApplicationStage {
  id: string;
  name: string;
  status: ApplicationStage_ApplicationStageStatus;
  startedAt?: number | undefined;
  memo: string;
  isVisible: boolean;
  priority: number;
  jobApplication?: JobApplication | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum ApplicationStage_ApplicationStageStatus {
  UNKNOWN = 0,
  PENDING = 1,
  PASSED = 2,
  FAILED = 3,
  SCHEDULED = 4,
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function applicationStage_ApplicationStageStatusFromJSON(object: any): ApplicationStage_ApplicationStageStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ApplicationStage_ApplicationStageStatus.UNKNOWN;
    case 1:
    case "PENDING":
      return ApplicationStage_ApplicationStageStatus.PENDING;
    case 2:
    case "PASSED":
      return ApplicationStage_ApplicationStageStatus.PASSED;
    case 3:
    case "FAILED":
      return ApplicationStage_ApplicationStageStatus.FAILED;
    case 4:
    case "SCHEDULED":
      return ApplicationStage_ApplicationStageStatus.SCHEDULED;
    case 5:
    case "CANCELLED":
      return ApplicationStage_ApplicationStageStatus.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApplicationStage_ApplicationStageStatus.UNRECOGNIZED;
  }
}

export function applicationStage_ApplicationStageStatusToJSON(object: ApplicationStage_ApplicationStageStatus): string {
  switch (object) {
    case ApplicationStage_ApplicationStageStatus.UNKNOWN:
      return "UNKNOWN";
    case ApplicationStage_ApplicationStageStatus.PENDING:
      return "PENDING";
    case ApplicationStage_ApplicationStageStatus.PASSED:
      return "PASSED";
    case ApplicationStage_ApplicationStageStatus.FAILED:
      return "FAILED";
    case ApplicationStage_ApplicationStageStatus.SCHEDULED:
      return "SCHEDULED";
    case ApplicationStage_ApplicationStageStatus.CANCELLED:
      return "CANCELLED";
    case ApplicationStage_ApplicationStageStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TurnOverRetrospective {
  id: string;
  name: string;
  salary: number;
  position: string;
  jobTitle: string;
  rank: string;
  department: string;
  reason: string;
  score: number;
  reviewSummary: string;
  joinedAt?: number | undefined;
  workType: string;
  employmentType?: TurnOverRetrospective_EmploymentType | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum TurnOverRetrospective_EmploymentType {
  EMPLOYMENT_TYPE_UNKNOWN = 0,
  FULL_TIME = 1,
  CONTRACT = 2,
  FREELANCER = 3,
  INTERN = 4,
  UNRECOGNIZED = -1,
}

export function turnOverRetrospective_EmploymentTypeFromJSON(object: any): TurnOverRetrospective_EmploymentType {
  switch (object) {
    case 0:
    case "EMPLOYMENT_TYPE_UNKNOWN":
      return TurnOverRetrospective_EmploymentType.EMPLOYMENT_TYPE_UNKNOWN;
    case 1:
    case "FULL_TIME":
      return TurnOverRetrospective_EmploymentType.FULL_TIME;
    case 2:
    case "CONTRACT":
      return TurnOverRetrospective_EmploymentType.CONTRACT;
    case 3:
    case "FREELANCER":
      return TurnOverRetrospective_EmploymentType.FREELANCER;
    case 4:
    case "INTERN":
      return TurnOverRetrospective_EmploymentType.INTERN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TurnOverRetrospective_EmploymentType.UNRECOGNIZED;
  }
}

export function turnOverRetrospective_EmploymentTypeToJSON(object: TurnOverRetrospective_EmploymentType): string {
  switch (object) {
    case TurnOverRetrospective_EmploymentType.EMPLOYMENT_TYPE_UNKNOWN:
      return "EMPLOYMENT_TYPE_UNKNOWN";
    case TurnOverRetrospective_EmploymentType.FULL_TIME:
      return "FULL_TIME";
    case TurnOverRetrospective_EmploymentType.CONTRACT:
      return "CONTRACT";
    case TurnOverRetrospective_EmploymentType.FREELANCER:
      return "FREELANCER";
    case TurnOverRetrospective_EmploymentType.INTERN:
      return "INTERN";
    case TurnOverRetrospective_EmploymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TurnOverRetrospectiveDetail {
  id: string;
  name: string;
  salary: number;
  position: string;
  jobTitle: string;
  rank: string;
  department: string;
  reason: string;
  score: number;
  reviewSummary: string;
  joinedAt?: number | undefined;
  workType: string;
  employmentType?: TurnOverRetrospectiveDetail_EmploymentType | undefined;
  memos: Memo[];
  attachments: Attachment[];
  createdAt: number;
  updatedAt: number;
}

export enum TurnOverRetrospectiveDetail_EmploymentType {
  EMPLOYMENT_TYPE_UNKNOWN = 0,
  FULL_TIME = 1,
  CONTRACT = 2,
  FREELANCER = 3,
  INTERN = 4,
  UNRECOGNIZED = -1,
}

export function turnOverRetrospectiveDetail_EmploymentTypeFromJSON(
  object: any,
): TurnOverRetrospectiveDetail_EmploymentType {
  switch (object) {
    case 0:
    case "EMPLOYMENT_TYPE_UNKNOWN":
      return TurnOverRetrospectiveDetail_EmploymentType.EMPLOYMENT_TYPE_UNKNOWN;
    case 1:
    case "FULL_TIME":
      return TurnOverRetrospectiveDetail_EmploymentType.FULL_TIME;
    case 2:
    case "CONTRACT":
      return TurnOverRetrospectiveDetail_EmploymentType.CONTRACT;
    case 3:
    case "FREELANCER":
      return TurnOverRetrospectiveDetail_EmploymentType.FREELANCER;
    case 4:
    case "INTERN":
      return TurnOverRetrospectiveDetail_EmploymentType.INTERN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TurnOverRetrospectiveDetail_EmploymentType.UNRECOGNIZED;
  }
}

export function turnOverRetrospectiveDetail_EmploymentTypeToJSON(
  object: TurnOverRetrospectiveDetail_EmploymentType,
): string {
  switch (object) {
    case TurnOverRetrospectiveDetail_EmploymentType.EMPLOYMENT_TYPE_UNKNOWN:
      return "EMPLOYMENT_TYPE_UNKNOWN";
    case TurnOverRetrospectiveDetail_EmploymentType.FULL_TIME:
      return "FULL_TIME";
    case TurnOverRetrospectiveDetail_EmploymentType.CONTRACT:
      return "CONTRACT";
    case TurnOverRetrospectiveDetail_EmploymentType.FREELANCER:
      return "FREELANCER";
    case TurnOverRetrospectiveDetail_EmploymentType.INTERN:
      return "INTERN";
    case TurnOverRetrospectiveDetail_EmploymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Attachment {
  id: string;
  type?: Attachment_AttachmentType | undefined;
  category: Attachment_AttachmentCategory;
  url: string;
  fileName: string;
  fileUrl: string;
  targetId: string;
  targetType: Attachment_AttachmentTargetType;
  isVisible: boolean;
  priority: number;
  createdAt: number;
  updatedAt: number;
}

export enum Attachment_AttachmentType {
  TYPE_UNKNOWN = 0,
  RESUME = 1,
  PORTFOLIO = 2,
  CERTIFICATE = 3,
  CAREER_STATEMENT = 4,
  ETC = 5,
  UNRECOGNIZED = -1,
}

export function attachment_AttachmentTypeFromJSON(object: any): Attachment_AttachmentType {
  switch (object) {
    case 0:
    case "TYPE_UNKNOWN":
      return Attachment_AttachmentType.TYPE_UNKNOWN;
    case 1:
    case "RESUME":
      return Attachment_AttachmentType.RESUME;
    case 2:
    case "PORTFOLIO":
      return Attachment_AttachmentType.PORTFOLIO;
    case 3:
    case "CERTIFICATE":
      return Attachment_AttachmentType.CERTIFICATE;
    case 4:
    case "CAREER_STATEMENT":
      return Attachment_AttachmentType.CAREER_STATEMENT;
    case 5:
    case "ETC":
      return Attachment_AttachmentType.ETC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attachment_AttachmentType.UNRECOGNIZED;
  }
}

export function attachment_AttachmentTypeToJSON(object: Attachment_AttachmentType): string {
  switch (object) {
    case Attachment_AttachmentType.TYPE_UNKNOWN:
      return "TYPE_UNKNOWN";
    case Attachment_AttachmentType.RESUME:
      return "RESUME";
    case Attachment_AttachmentType.PORTFOLIO:
      return "PORTFOLIO";
    case Attachment_AttachmentType.CERTIFICATE:
      return "CERTIFICATE";
    case Attachment_AttachmentType.CAREER_STATEMENT:
      return "CAREER_STATEMENT";
    case Attachment_AttachmentType.ETC:
      return "ETC";
    case Attachment_AttachmentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Attachment_AttachmentCategory {
  CATEGORY_UNKNOWN = 0,
  FILE = 1,
  URL = 2,
  UNRECOGNIZED = -1,
}

export function attachment_AttachmentCategoryFromJSON(object: any): Attachment_AttachmentCategory {
  switch (object) {
    case 0:
    case "CATEGORY_UNKNOWN":
      return Attachment_AttachmentCategory.CATEGORY_UNKNOWN;
    case 1:
    case "FILE":
      return Attachment_AttachmentCategory.FILE;
    case 2:
    case "URL":
      return Attachment_AttachmentCategory.URL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attachment_AttachmentCategory.UNRECOGNIZED;
  }
}

export function attachment_AttachmentCategoryToJSON(object: Attachment_AttachmentCategory): string {
  switch (object) {
    case Attachment_AttachmentCategory.CATEGORY_UNKNOWN:
      return "CATEGORY_UNKNOWN";
    case Attachment_AttachmentCategory.FILE:
      return "FILE";
    case Attachment_AttachmentCategory.URL:
      return "URL";
    case Attachment_AttachmentCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Attachment_AttachmentTargetType {
  TARGET_TYPE_UNKNOWN = 0,
  ENTITY_RECORD = 1,
  ENTITY_RESUME = 2,
  ENTITY_TURN_OVER_GOAL = 3,
  ENTITY_TURN_OVER_CHALLENGE = 4,
  ENTITY_TURN_OVER_RETROSPECTIVE = 5,
  UNRECOGNIZED = -1,
}

export function attachment_AttachmentTargetTypeFromJSON(object: any): Attachment_AttachmentTargetType {
  switch (object) {
    case 0:
    case "TARGET_TYPE_UNKNOWN":
      return Attachment_AttachmentTargetType.TARGET_TYPE_UNKNOWN;
    case 1:
    case "ENTITY_RECORD":
      return Attachment_AttachmentTargetType.ENTITY_RECORD;
    case 2:
    case "ENTITY_RESUME":
      return Attachment_AttachmentTargetType.ENTITY_RESUME;
    case 3:
    case "ENTITY_TURN_OVER_GOAL":
      return Attachment_AttachmentTargetType.ENTITY_TURN_OVER_GOAL;
    case 4:
    case "ENTITY_TURN_OVER_CHALLENGE":
      return Attachment_AttachmentTargetType.ENTITY_TURN_OVER_CHALLENGE;
    case 5:
    case "ENTITY_TURN_OVER_RETROSPECTIVE":
      return Attachment_AttachmentTargetType.ENTITY_TURN_OVER_RETROSPECTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attachment_AttachmentTargetType.UNRECOGNIZED;
  }
}

export function attachment_AttachmentTargetTypeToJSON(object: Attachment_AttachmentTargetType): string {
  switch (object) {
    case Attachment_AttachmentTargetType.TARGET_TYPE_UNKNOWN:
      return "TARGET_TYPE_UNKNOWN";
    case Attachment_AttachmentTargetType.ENTITY_RECORD:
      return "ENTITY_RECORD";
    case Attachment_AttachmentTargetType.ENTITY_RESUME:
      return "ENTITY_RESUME";
    case Attachment_AttachmentTargetType.ENTITY_TURN_OVER_GOAL:
      return "ENTITY_TURN_OVER_GOAL";
    case Attachment_AttachmentTargetType.ENTITY_TURN_OVER_CHALLENGE:
      return "ENTITY_TURN_OVER_CHALLENGE";
    case Attachment_AttachmentTargetType.ENTITY_TURN_OVER_RETROSPECTIVE:
      return "ENTITY_TURN_OVER_RETROSPECTIVE";
    case Attachment_AttachmentTargetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Memo {
  id: string;
  content: string;
  targetId: string;
  targetType: Memo_MemoTargetType;
  isVisible: boolean;
  priority: number;
  createdAt: number;
  updatedAt: number;
}

export enum Memo_MemoTargetType {
  UNKNOWN = 0,
  TURN_OVER_GOAL = 1,
  TURN_OVER_CHALLENGE = 2,
  TURN_OVER_RETROSPECT = 3,
  UNRECOGNIZED = -1,
}

export function memo_MemoTargetTypeFromJSON(object: any): Memo_MemoTargetType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Memo_MemoTargetType.UNKNOWN;
    case 1:
    case "TURN_OVER_GOAL":
      return Memo_MemoTargetType.TURN_OVER_GOAL;
    case 2:
    case "TURN_OVER_CHALLENGE":
      return Memo_MemoTargetType.TURN_OVER_CHALLENGE;
    case 3:
    case "TURN_OVER_RETROSPECT":
      return Memo_MemoTargetType.TURN_OVER_RETROSPECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Memo_MemoTargetType.UNRECOGNIZED;
  }
}

export function memo_MemoTargetTypeToJSON(object: Memo_MemoTargetType): string {
  switch (object) {
    case Memo_MemoTargetType.UNKNOWN:
      return "UNKNOWN";
    case Memo_MemoTargetType.TURN_OVER_GOAL:
      return "TURN_OVER_GOAL";
    case Memo_MemoTargetType.TURN_OVER_CHALLENGE:
      return "TURN_OVER_CHALLENGE";
    case Memo_MemoTargetType.TURN_OVER_RETROSPECT:
      return "TURN_OVER_RETROSPECT";
    case Memo_MemoTargetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Notice {
  id: string;
  title: string;
  content: string;
  isPinned: boolean;
  createdAt: number;
  updatedAt: number;
}

export interface Plan {
  id: string;
  name: string;
  type: Plan_PlanType;
  price: number;
  currency: string;
  priority: number;
  description?: string | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum Plan_PlanType {
  UNKNOWN = 0,
  FREE = 1,
  PREMIUM = 2,
  UNRECOGNIZED = -1,
}

export function plan_PlanTypeFromJSON(object: any): Plan_PlanType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Plan_PlanType.UNKNOWN;
    case 1:
    case "FREE":
      return Plan_PlanType.FREE;
    case 2:
    case "PREMIUM":
      return Plan_PlanType.PREMIUM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Plan_PlanType.UNRECOGNIZED;
  }
}

export function plan_PlanTypeToJSON(object: Plan_PlanType): string {
  switch (object) {
    case Plan_PlanType.UNKNOWN:
      return "UNKNOWN";
    case Plan_PlanType.FREE:
      return "FREE";
    case Plan_PlanType.PREMIUM:
      return "PREMIUM";
    case Plan_PlanType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PlanSubscription {
  id: string;
  durationMonths: string;
  totalPrice: number;
  monthlyEquivalent: number;
  savingsAmount: number;
  discountRate: number;
  priority: number;
  plan?: Plan | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface Feature {
  id: string;
  name: string;
  domain: string;
  action: string;
  createdAt: number;
  updatedAt: number;
}

export interface WorkerSubscription {
  id: string;
  planName: string;
  planType: Plan_PlanType;
  status: WorkerSubscription_SubscriptionStatus;
  startedAt: number;
  endedAt: number;
  cancelledAt?: number | undefined;
  cancelReason?: string | undefined;
  worker?: Worker | undefined;
  createdAt: number;
  updatedAt: number;
}

export enum WorkerSubscription_SubscriptionStatus {
  UNKNOWN = 0,
  ACTIVE = 1,
  EXPIRED = 2,
  CANCELLED = 3,
  UNRECOGNIZED = -1,
}

export function workerSubscription_SubscriptionStatusFromJSON(object: any): WorkerSubscription_SubscriptionStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return WorkerSubscription_SubscriptionStatus.UNKNOWN;
    case 1:
    case "ACTIVE":
      return WorkerSubscription_SubscriptionStatus.ACTIVE;
    case 2:
    case "EXPIRED":
      return WorkerSubscription_SubscriptionStatus.EXPIRED;
    case 3:
    case "CANCELLED":
      return WorkerSubscription_SubscriptionStatus.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkerSubscription_SubscriptionStatus.UNRECOGNIZED;
  }
}

export function workerSubscription_SubscriptionStatusToJSON(object: WorkerSubscription_SubscriptionStatus): string {
  switch (object) {
    case WorkerSubscription_SubscriptionStatus.UNKNOWN:
      return "UNKNOWN";
    case WorkerSubscription_SubscriptionStatus.ACTIVE:
      return "ACTIVE";
    case WorkerSubscription_SubscriptionStatus.EXPIRED:
      return "EXPIRED";
    case WorkerSubscription_SubscriptionStatus.CANCELLED:
      return "CANCELLED";
    case WorkerSubscription_SubscriptionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WorkerFeatureUsage {
  id: string;
  currentCount: number;
  limitCount?: number | undefined;
  lastUsedAt: number;
  worker?: Worker | undefined;
  createdAt: number;
  updatedAt: number;
}

export interface PlanFeature {
  id: string;
  plan?: Plan | undefined;
  feature?: Feature | undefined;
  limitCount: number;
  description: string;
  createdAt: number;
  updatedAt: number;
}

export interface Payment {
  id: string;
  amount: number;
  currency: string;
  status: Payment_PaymentStatus;
  paymentMethod: Payment_PaymentMethod;
  paymentProvider: string;
  providerPaymentId: string;
  paidAt?: number | undefined;
  refundedAt?: number | undefined;
  refundAmount: number;
  refundReason?: string | undefined;
  failureReason?: string | undefined;
  failureCode?: string | undefined;
  metadataJson?: string | undefined;
  worker?: Worker | undefined;
  paymentTransactions: PaymentTransaction[];
  createdAt: number;
  updatedAt: number;
}

export enum Payment_PaymentStatus {
  UNKNOWN = 0,
  PENDING = 1,
  COMPLETED = 2,
  FAILED = 3,
  REFUNDED = 4,
  UNRECOGNIZED = -1,
}

export function payment_PaymentStatusFromJSON(object: any): Payment_PaymentStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Payment_PaymentStatus.UNKNOWN;
    case 1:
    case "PENDING":
      return Payment_PaymentStatus.PENDING;
    case 2:
    case "COMPLETED":
      return Payment_PaymentStatus.COMPLETED;
    case 3:
    case "FAILED":
      return Payment_PaymentStatus.FAILED;
    case 4:
    case "REFUNDED":
      return Payment_PaymentStatus.REFUNDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Payment_PaymentStatus.UNRECOGNIZED;
  }
}

export function payment_PaymentStatusToJSON(object: Payment_PaymentStatus): string {
  switch (object) {
    case Payment_PaymentStatus.UNKNOWN:
      return "UNKNOWN";
    case Payment_PaymentStatus.PENDING:
      return "PENDING";
    case Payment_PaymentStatus.COMPLETED:
      return "COMPLETED";
    case Payment_PaymentStatus.FAILED:
      return "FAILED";
    case Payment_PaymentStatus.REFUNDED:
      return "REFUNDED";
    case Payment_PaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Payment_PaymentMethod {
  METHOD_UNKNOWN = 0,
  CARD = 1,
  CASH = 2,
  UNRECOGNIZED = -1,
}

export function payment_PaymentMethodFromJSON(object: any): Payment_PaymentMethod {
  switch (object) {
    case 0:
    case "METHOD_UNKNOWN":
      return Payment_PaymentMethod.METHOD_UNKNOWN;
    case 1:
    case "CARD":
      return Payment_PaymentMethod.CARD;
    case 2:
    case "CASH":
      return Payment_PaymentMethod.CASH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Payment_PaymentMethod.UNRECOGNIZED;
  }
}

export function payment_PaymentMethodToJSON(object: Payment_PaymentMethod): string {
  switch (object) {
    case Payment_PaymentMethod.METHOD_UNKNOWN:
      return "METHOD_UNKNOWN";
    case Payment_PaymentMethod.CARD:
      return "CARD";
    case Payment_PaymentMethod.CASH:
      return "CASH";
    case Payment_PaymentMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PaymentTransaction {
  id: string;
  transactionType: PaymentTransaction_TransactionType;
  status: string;
  amount: number;
  transactionId?: string | undefined;
  requestData?: string | undefined;
  responseData?: string | undefined;
  errorMessage?: string | undefined;
  receiptUrl?: string | undefined;
  payment?: Payment | undefined;
  createdAt: number;
}

export enum PaymentTransaction_TransactionType {
  TYPE_UNKNOWN = 0,
  PAYMENT = 1,
  REFUND = 2,
  PARTIAL_REFUND = 3,
  CANCEL = 4,
  UNRECOGNIZED = -1,
}

export function paymentTransaction_TransactionTypeFromJSON(object: any): PaymentTransaction_TransactionType {
  switch (object) {
    case 0:
    case "TYPE_UNKNOWN":
      return PaymentTransaction_TransactionType.TYPE_UNKNOWN;
    case 1:
    case "PAYMENT":
      return PaymentTransaction_TransactionType.PAYMENT;
    case 2:
    case "REFUND":
      return PaymentTransaction_TransactionType.REFUND;
    case 3:
    case "PARTIAL_REFUND":
      return PaymentTransaction_TransactionType.PARTIAL_REFUND;
    case 4:
    case "CANCEL":
      return PaymentTransaction_TransactionType.CANCEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentTransaction_TransactionType.UNRECOGNIZED;
  }
}

export function paymentTransaction_TransactionTypeToJSON(object: PaymentTransaction_TransactionType): string {
  switch (object) {
    case PaymentTransaction_TransactionType.TYPE_UNKNOWN:
      return "TYPE_UNKNOWN";
    case PaymentTransaction_TransactionType.PAYMENT:
      return "PAYMENT";
    case PaymentTransaction_TransactionType.REFUND:
      return "REFUND";
    case PaymentTransaction_TransactionType.PARTIAL_REFUND:
      return "PARTIAL_REFUND";
    case PaymentTransaction_TransactionType.CANCEL:
      return "CANCEL";
    case PaymentTransaction_TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Staff {
  id: string;
  username: string;
  name: string;
  email: string;
  phone?: string | undefined;
  isActive: boolean;
  createdAt: number;
  updatedAt: number;
}

function createBaseWorker(): Worker {
  return {
    id: "",
    nickName: "",
    phone: "",
    email: "",
    birthDate: undefined,
    gender: undefined,
    status: 0,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Worker: MessageFns<Worker> = {
  encode(message: Worker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nickName !== "") {
      writer.uint32(18).string(message.nickName);
    }
    if (message.phone !== "") {
      writer.uint32(26).string(message.phone);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.birthDate !== undefined) {
      writer.uint32(40).uint64(message.birthDate);
    }
    if (message.gender !== undefined) {
      writer.uint32(48).int32(message.gender);
    }
    if (message.status !== 0) {
      writer.uint32(776).int32(message.status);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.birthDate = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 97: {
          if (tag !== 776) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nickName: isSet(object.nickName) ? globalThis.String(object.nickName) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      birthDate: isSet(object.birthDate) ? globalThis.Number(object.birthDate) : undefined,
      gender: isSet(object.gender) ? worker_GenderFromJSON(object.gender) : undefined,
      status: isSet(object.status) ? worker_WorkerStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Worker): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nickName !== "") {
      obj.nickName = message.nickName;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.birthDate !== undefined) {
      obj.birthDate = Math.round(message.birthDate);
    }
    if (message.gender !== undefined) {
      obj.gender = worker_GenderToJSON(message.gender);
    }
    if (message.status !== 0) {
      obj.status = worker_WorkerStatusToJSON(message.status);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Worker>, I>>(base?: I): Worker {
    return Worker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Worker>, I>>(object: I): Worker {
    const message = createBaseWorker();
    message.id = object.id ?? "";
    message.nickName = object.nickName ?? "";
    message.phone = object.phone ?? "";
    message.email = object.email ?? "";
    message.birthDate = object.birthDate ?? undefined;
    message.gender = object.gender ?? undefined;
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseAccount(): Account {
  return { id: "", type: 0, providerId: "", email: "", worker: undefined, createdAt: 0, updatedAt: 0 };
}

export const Account: MessageFns<Account> = {
  encode(message: Account, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.providerId !== "") {
      writer.uint32(26).string(message.providerId);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Account {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? account_AccountTypeFromJSON(object.type) : 0,
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = account_AccountTypeToJSON(message.type);
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account>, I>>(base?: I): Account {
    return Account.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account>, I>>(object: I): Account {
    const message = createBaseAccount();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.providerId = object.providerId ?? "";
    message.email = object.email ?? "";
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseResume(): Resume {
  return {
    id: "",
    title: "",
    name: "",
    phone: "",
    email: "",
    birthDate: undefined,
    gender: undefined,
    position: "",
    isPublic: undefined,
    isDefault: undefined,
    description: "",
    worker: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Resume: MessageFns<Resume> = {
  encode(message: Resume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== "") {
      writer.uint32(34).string(message.phone);
    }
    if (message.email !== "") {
      writer.uint32(42).string(message.email);
    }
    if (message.birthDate !== undefined) {
      writer.uint32(48).uint64(message.birthDate);
    }
    if (message.gender !== undefined) {
      writer.uint32(56).int32(message.gender);
    }
    if (message.position !== "") {
      writer.uint32(66).string(message.position);
    }
    if (message.isPublic !== undefined) {
      writer.uint32(72).bool(message.isPublic);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(80).bool(message.isDefault);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.birthDate = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resume {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      birthDate: isSet(object.birthDate) ? globalThis.Number(object.birthDate) : undefined,
      gender: isSet(object.gender) ? resume_GenderFromJSON(object.gender) : undefined,
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      isPublic: isSet(object.isPublic) ? globalThis.Boolean(object.isPublic) : undefined,
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Resume): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.birthDate !== undefined) {
      obj.birthDate = Math.round(message.birthDate);
    }
    if (message.gender !== undefined) {
      obj.gender = resume_GenderToJSON(message.gender);
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.isPublic !== undefined) {
      obj.isPublic = message.isPublic;
    }
    if (message.isDefault !== undefined) {
      obj.isDefault = message.isDefault;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resume>, I>>(base?: I): Resume {
    return Resume.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resume>, I>>(object: I): Resume {
    const message = createBaseResume();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.name = object.name ?? "";
    message.phone = object.phone ?? "";
    message.email = object.email ?? "";
    message.birthDate = object.birthDate ?? undefined;
    message.gender = object.gender ?? undefined;
    message.position = object.position ?? "";
    message.isPublic = object.isPublic ?? undefined;
    message.isDefault = object.isDefault ?? undefined;
    message.description = object.description ?? "";
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseResumeDetail(): ResumeDetail {
  return {
    id: "",
    title: "",
    name: "",
    phone: "",
    email: "",
    birthDate: undefined,
    gender: undefined,
    position: "",
    isPublic: undefined,
    isDefault: undefined,
    publicId: "",
    description: "",
    worker: undefined,
    careers: [],
    educations: [],
    activities: [],
    projects: [],
    languageSkills: [],
    attachments: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const ResumeDetail: MessageFns<ResumeDetail> = {
  encode(message: ResumeDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== "") {
      writer.uint32(34).string(message.phone);
    }
    if (message.email !== "") {
      writer.uint32(42).string(message.email);
    }
    if (message.birthDate !== undefined) {
      writer.uint32(48).uint64(message.birthDate);
    }
    if (message.gender !== undefined) {
      writer.uint32(56).int32(message.gender);
    }
    if (message.position !== "") {
      writer.uint32(66).string(message.position);
    }
    if (message.isPublic !== undefined) {
      writer.uint32(72).bool(message.isPublic);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(80).bool(message.isDefault);
    }
    if (message.publicId !== "") {
      writer.uint32(90).string(message.publicId);
    }
    if (message.description !== "") {
      writer.uint32(98).string(message.description);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    for (const v of message.careers) {
      Career.encode(v!, writer.uint32(410).fork()).join();
    }
    for (const v of message.educations) {
      Education.encode(v!, writer.uint32(418).fork()).join();
    }
    for (const v of message.activities) {
      Activity.encode(v!, writer.uint32(426).fork()).join();
    }
    for (const v of message.projects) {
      Project.encode(v!, writer.uint32(434).fork()).join();
    }
    for (const v of message.languageSkills) {
      LanguageSkill.encode(v!, writer.uint32(442).fork()).join();
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(450).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.birthDate = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.publicId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.careers.push(Career.decode(reader, reader.uint32()));
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.educations.push(Education.decode(reader, reader.uint32()));
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.activities.push(Activity.decode(reader, reader.uint32()));
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.projects.push(Project.decode(reader, reader.uint32()));
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }

          message.languageSkills.push(LanguageSkill.decode(reader, reader.uint32()));
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumeDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      birthDate: isSet(object.birthDate) ? globalThis.Number(object.birthDate) : undefined,
      gender: isSet(object.gender) ? resume_GenderFromJSON(object.gender) : undefined,
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      isPublic: isSet(object.isPublic) ? globalThis.Boolean(object.isPublic) : undefined,
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : undefined,
      publicId: isSet(object.publicId) ? globalThis.String(object.publicId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      careers: globalThis.Array.isArray(object?.careers) ? object.careers.map((e: any) => Career.fromJSON(e)) : [],
      educations: globalThis.Array.isArray(object?.educations)
        ? object.educations.map((e: any) => Education.fromJSON(e))
        : [],
      activities: globalThis.Array.isArray(object?.activities)
        ? object.activities.map((e: any) => Activity.fromJSON(e))
        : [],
      projects: globalThis.Array.isArray(object?.projects) ? object.projects.map((e: any) => Project.fromJSON(e)) : [],
      languageSkills: globalThis.Array.isArray(object?.languageSkills)
        ? object.languageSkills.map((e: any) => LanguageSkill.fromJSON(e))
        : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: ResumeDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.birthDate !== undefined) {
      obj.birthDate = Math.round(message.birthDate);
    }
    if (message.gender !== undefined) {
      obj.gender = resume_GenderToJSON(message.gender);
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.isPublic !== undefined) {
      obj.isPublic = message.isPublic;
    }
    if (message.isDefault !== undefined) {
      obj.isDefault = message.isDefault;
    }
    if (message.publicId !== "") {
      obj.publicId = message.publicId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.careers?.length) {
      obj.careers = message.careers.map((e) => Career.toJSON(e));
    }
    if (message.educations?.length) {
      obj.educations = message.educations.map((e) => Education.toJSON(e));
    }
    if (message.activities?.length) {
      obj.activities = message.activities.map((e) => Activity.toJSON(e));
    }
    if (message.projects?.length) {
      obj.projects = message.projects.map((e) => Project.toJSON(e));
    }
    if (message.languageSkills?.length) {
      obj.languageSkills = message.languageSkills.map((e) => LanguageSkill.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResumeDetail>, I>>(base?: I): ResumeDetail {
    return ResumeDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResumeDetail>, I>>(object: I): ResumeDetail {
    const message = createBaseResumeDetail();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.name = object.name ?? "";
    message.phone = object.phone ?? "";
    message.email = object.email ?? "";
    message.birthDate = object.birthDate ?? undefined;
    message.gender = object.gender ?? undefined;
    message.position = object.position ?? "";
    message.isPublic = object.isPublic ?? undefined;
    message.isDefault = object.isDefault ?? undefined;
    message.publicId = object.publicId ?? "";
    message.description = object.description ?? "";
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.careers = object.careers?.map((e) => Career.fromPartial(e)) || [];
    message.educations = object.educations?.map((e) => Education.fromPartial(e)) || [];
    message.activities = object.activities?.map((e) => Activity.fromPartial(e)) || [];
    message.projects = object.projects?.map((e) => Project.fromPartial(e)) || [];
    message.languageSkills = object.languageSkills?.map((e) => LanguageSkill.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseCareer(): Career {
  return {
    id: "",
    name: "",
    startedAt: undefined,
    endedAt: undefined,
    isWorking: undefined,
    position: "",
    employmentType: undefined,
    department: "",
    jobTitle: "",
    rank: "",
    salary: 0,
    description: "",
    isVisible: false,
    priority: 0,
    resume: undefined,
    salaries: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Career: MessageFns<Career> = {
  encode(message: Career, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(24).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(32).uint64(message.endedAt);
    }
    if (message.isWorking !== undefined) {
      writer.uint32(40).bool(message.isWorking);
    }
    if (message.position !== "") {
      writer.uint32(50).string(message.position);
    }
    if (message.employmentType !== undefined) {
      writer.uint32(56).int32(message.employmentType);
    }
    if (message.department !== "") {
      writer.uint32(66).string(message.department);
    }
    if (message.jobTitle !== "") {
      writer.uint32(74).string(message.jobTitle);
    }
    if (message.rank !== "") {
      writer.uint32(82).string(message.rank);
    }
    if (message.salary !== 0) {
      writer.uint32(88).uint32(message.salary);
    }
    if (message.description !== "") {
      writer.uint32(98).string(message.description);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.resume !== undefined) {
      Resume.encode(message.resume, writer.uint32(402).fork()).join();
    }
    for (const v of message.salaries) {
      Salary.encode(v!, writer.uint32(410).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Career {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCareer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isWorking = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.employmentType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.department = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.jobTitle = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rank = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.salary = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.resume = Resume.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.salaries.push(Salary.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Career {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      isWorking: isSet(object.isWorking) ? globalThis.Boolean(object.isWorking) : undefined,
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      employmentType: isSet(object.employmentType) ? career_EmploymentTypeFromJSON(object.employmentType) : undefined,
      department: isSet(object.department) ? globalThis.String(object.department) : "",
      jobTitle: isSet(object.jobTitle) ? globalThis.String(object.jobTitle) : "",
      rank: isSet(object.rank) ? globalThis.String(object.rank) : "",
      salary: isSet(object.salary) ? globalThis.Number(object.salary) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      resume: isSet(object.resume) ? Resume.fromJSON(object.resume) : undefined,
      salaries: globalThis.Array.isArray(object?.salaries) ? object.salaries.map((e: any) => Salary.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Career): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.isWorking !== undefined) {
      obj.isWorking = message.isWorking;
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.employmentType !== undefined) {
      obj.employmentType = career_EmploymentTypeToJSON(message.employmentType);
    }
    if (message.department !== "") {
      obj.department = message.department;
    }
    if (message.jobTitle !== "") {
      obj.jobTitle = message.jobTitle;
    }
    if (message.rank !== "") {
      obj.rank = message.rank;
    }
    if (message.salary !== 0) {
      obj.salary = Math.round(message.salary);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.resume !== undefined) {
      obj.resume = Resume.toJSON(message.resume);
    }
    if (message.salaries?.length) {
      obj.salaries = message.salaries.map((e) => Salary.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Career>, I>>(base?: I): Career {
    return Career.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Career>, I>>(object: I): Career {
    const message = createBaseCareer();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.isWorking = object.isWorking ?? undefined;
    message.position = object.position ?? "";
    message.employmentType = object.employmentType ?? undefined;
    message.department = object.department ?? "";
    message.jobTitle = object.jobTitle ?? "";
    message.rank = object.rank ?? "";
    message.salary = object.salary ?? 0;
    message.description = object.description ?? "";
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.resume = (object.resume !== undefined && object.resume !== null)
      ? Resume.fromPartial(object.resume)
      : undefined;
    message.salaries = object.salaries?.map((e) => Salary.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseSalary(): Salary {
  return {
    id: "",
    amount: 0,
    memo: "",
    negotiationDate: undefined,
    isVisible: false,
    priority: 0,
    career: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Salary: MessageFns<Salary> = {
  encode(message: Salary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    if (message.memo !== "") {
      writer.uint32(26).string(message.memo);
    }
    if (message.negotiationDate !== undefined) {
      writer.uint32(32).uint64(message.negotiationDate);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.career !== undefined) {
      Career.encode(message.career, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Salary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSalary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.negotiationDate = longToNumber(reader.uint64());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.career = Career.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Salary {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      negotiationDate: isSet(object.negotiationDate) ? globalThis.Number(object.negotiationDate) : undefined,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      career: isSet(object.career) ? Career.fromJSON(object.career) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Salary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.negotiationDate !== undefined) {
      obj.negotiationDate = Math.round(message.negotiationDate);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.career !== undefined) {
      obj.career = Career.toJSON(message.career);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Salary>, I>>(base?: I): Salary {
    return Salary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Salary>, I>>(object: I): Salary {
    const message = createBaseSalary();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.memo = object.memo ?? "";
    message.negotiationDate = object.negotiationDate ?? undefined;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.career = (object.career !== undefined && object.career !== null)
      ? Career.fromPartial(object.career)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseEducation(): Education {
  return {
    id: "",
    major: "",
    name: "",
    description: "",
    status: undefined,
    startedAt: undefined,
    endedAt: undefined,
    isVisible: false,
    priority: 0,
    resume: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Education: MessageFns<Education> = {
  encode(message: Education, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.major !== "") {
      writer.uint32(18).string(message.major);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.status !== undefined) {
      writer.uint32(40).int32(message.status);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(48).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(56).uint64(message.endedAt);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.resume !== undefined) {
      Resume.encode(message.resume, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Education {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEducation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.major = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.resume = Resume.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Education {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      major: isSet(object.major) ? globalThis.String(object.major) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      status: isSet(object.status) ? education_EducationStatusFromJSON(object.status) : undefined,
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      resume: isSet(object.resume) ? Resume.fromJSON(object.resume) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Education): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.major !== "") {
      obj.major = message.major;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.status !== undefined) {
      obj.status = education_EducationStatusToJSON(message.status);
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.resume !== undefined) {
      obj.resume = Resume.toJSON(message.resume);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Education>, I>>(base?: I): Education {
    return Education.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Education>, I>>(object: I): Education {
    const message = createBaseEducation();
    message.id = object.id ?? "";
    message.major = object.major ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.status = object.status ?? undefined;
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.resume = (object.resume !== undefined && object.resume !== null)
      ? Resume.fromPartial(object.resume)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseActivity(): Activity {
  return {
    id: "",
    type: undefined,
    name: "",
    organization: "",
    certificateNumber: "",
    startedAt: undefined,
    endedAt: undefined,
    description: "",
    isVisible: false,
    priority: 0,
    resume: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Activity: MessageFns<Activity> = {
  encode(message: Activity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== undefined) {
      writer.uint32(16).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.organization !== "") {
      writer.uint32(34).string(message.organization);
    }
    if (message.certificateNumber !== "") {
      writer.uint32(42).string(message.certificateNumber);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(48).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(56).uint64(message.endedAt);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.resume !== undefined) {
      Resume.encode(message.resume, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Activity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.organization = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.certificateNumber = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.resume = Resume.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Activity {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? activity_ActivityTypeFromJSON(object.type) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
      certificateNumber: isSet(object.certificateNumber) ? globalThis.String(object.certificateNumber) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      resume: isSet(object.resume) ? Resume.fromJSON(object.resume) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Activity): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== undefined) {
      obj.type = activity_ActivityTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    if (message.certificateNumber !== "") {
      obj.certificateNumber = message.certificateNumber;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.resume !== undefined) {
      obj.resume = Resume.toJSON(message.resume);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Activity>, I>>(base?: I): Activity {
    return Activity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Activity>, I>>(object: I): Activity {
    const message = createBaseActivity();
    message.id = object.id ?? "";
    message.type = object.type ?? undefined;
    message.name = object.name ?? "";
    message.organization = object.organization ?? "";
    message.certificateNumber = object.certificateNumber ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.description = object.description ?? "";
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.resume = (object.resume !== undefined && object.resume !== null)
      ? Resume.fromPartial(object.resume)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseProject(): Project {
  return {
    id: "",
    title: "",
    affiliation: "",
    role: "",
    description: "",
    startedAt: undefined,
    endedAt: undefined,
    isVisible: false,
    priority: 0,
    resume: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Project: MessageFns<Project> = {
  encode(message: Project, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.affiliation !== "") {
      writer.uint32(26).string(message.affiliation);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(48).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(56).uint64(message.endedAt);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.resume !== undefined) {
      Resume.encode(message.resume, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Project {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.affiliation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.resume = Resume.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Project {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      affiliation: isSet(object.affiliation) ? globalThis.String(object.affiliation) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      resume: isSet(object.resume) ? Resume.fromJSON(object.resume) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Project): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.affiliation !== "") {
      obj.affiliation = message.affiliation;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.resume !== undefined) {
      obj.resume = Resume.toJSON(message.resume);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Project>, I>>(base?: I): Project {
    return Project.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Project>, I>>(object: I): Project {
    const message = createBaseProject();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.affiliation = object.affiliation ?? "";
    message.role = object.role ?? "";
    message.description = object.description ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.resume = (object.resume !== undefined && object.resume !== null)
      ? Resume.fromPartial(object.resume)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseLanguageSkill(): LanguageSkill {
  return {
    id: "",
    language: undefined,
    level: undefined,
    isVisible: false,
    priority: 0,
    resume: undefined,
    languageTests: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const LanguageSkill: MessageFns<LanguageSkill> = {
  encode(message: LanguageSkill, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.language !== undefined) {
      writer.uint32(16).int32(message.language);
    }
    if (message.level !== undefined) {
      writer.uint32(24).int32(message.level);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.resume !== undefined) {
      Resume.encode(message.resume, writer.uint32(402).fork()).join();
    }
    for (const v of message.languageTests) {
      LanguageTest.encode(v!, writer.uint32(410).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageSkill {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageSkill();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.resume = Resume.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.languageTests.push(LanguageTest.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageSkill {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      language: isSet(object.language) ? languageSkill_LanguageFromJSON(object.language) : undefined,
      level: isSet(object.level) ? languageSkill_LanguageLevelFromJSON(object.level) : undefined,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      resume: isSet(object.resume) ? Resume.fromJSON(object.resume) : undefined,
      languageTests: globalThis.Array.isArray(object?.languageTests)
        ? object.languageTests.map((e: any) => LanguageTest.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: LanguageSkill): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.language !== undefined) {
      obj.language = languageSkill_LanguageToJSON(message.language);
    }
    if (message.level !== undefined) {
      obj.level = languageSkill_LanguageLevelToJSON(message.level);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.resume !== undefined) {
      obj.resume = Resume.toJSON(message.resume);
    }
    if (message.languageTests?.length) {
      obj.languageTests = message.languageTests.map((e) => LanguageTest.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LanguageSkill>, I>>(base?: I): LanguageSkill {
    return LanguageSkill.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LanguageSkill>, I>>(object: I): LanguageSkill {
    const message = createBaseLanguageSkill();
    message.id = object.id ?? "";
    message.language = object.language ?? undefined;
    message.level = object.level ?? undefined;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.resume = (object.resume !== undefined && object.resume !== null)
      ? Resume.fromPartial(object.resume)
      : undefined;
    message.languageTests = object.languageTests?.map((e) => LanguageTest.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseLanguageTest(): LanguageTest {
  return {
    id: "",
    name: "",
    score: "",
    acquiredAt: undefined,
    isVisible: false,
    priority: 0,
    languageSkill: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const LanguageTest: MessageFns<LanguageTest> = {
  encode(message: LanguageTest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.score !== "") {
      writer.uint32(26).string(message.score);
    }
    if (message.acquiredAt !== undefined) {
      writer.uint32(32).uint64(message.acquiredAt);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.languageSkill !== undefined) {
      LanguageSkill.encode(message.languageSkill, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.score = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.acquiredAt = longToNumber(reader.uint64());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.languageSkill = LanguageSkill.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageTest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      score: isSet(object.score) ? globalThis.String(object.score) : "",
      acquiredAt: isSet(object.acquiredAt) ? globalThis.Number(object.acquiredAt) : undefined,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      languageSkill: isSet(object.languageSkill) ? LanguageSkill.fromJSON(object.languageSkill) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: LanguageTest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.score !== "") {
      obj.score = message.score;
    }
    if (message.acquiredAt !== undefined) {
      obj.acquiredAt = Math.round(message.acquiredAt);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.languageSkill !== undefined) {
      obj.languageSkill = LanguageSkill.toJSON(message.languageSkill);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LanguageTest>, I>>(base?: I): LanguageTest {
    return LanguageTest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LanguageTest>, I>>(object: I): LanguageTest {
    const message = createBaseLanguageTest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.score = object.score ?? "";
    message.acquiredAt = object.acquiredAt ?? undefined;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.languageSkill = (object.languageSkill !== undefined && object.languageSkill !== null)
      ? LanguageSkill.fromPartial(object.languageSkill)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseRecord(): Record {
  return {
    id: "",
    title: "",
    type: 0,
    description: "",
    startedAt: 0,
    endedAt: 0,
    worker: undefined,
    recordGroup: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Record: MessageFns<Record> = {
  encode(message: Record, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.startedAt !== 0) {
      writer.uint32(40).uint64(message.startedAt);
    }
    if (message.endedAt !== 0) {
      writer.uint32(48).uint64(message.endedAt);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.recordGroup !== undefined) {
      RecordGroup.encode(message.recordGroup, writer.uint32(410).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Record {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.recordGroup = RecordGroup.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Record {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      type: isSet(object.type) ? record_RecordTypeFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : 0,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : 0,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      recordGroup: isSet(object.recordGroup) ? RecordGroup.fromJSON(object.recordGroup) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Record): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.type !== 0) {
      obj.type = record_RecordTypeToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.startedAt !== 0) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== 0) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.recordGroup !== undefined) {
      obj.recordGroup = RecordGroup.toJSON(message.recordGroup);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Record>, I>>(base?: I): Record {
    return Record.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Record>, I>>(object: I): Record {
    const message = createBaseRecord();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    message.startedAt = object.startedAt ?? 0;
    message.endedAt = object.endedAt ?? 0;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.recordGroup = (object.recordGroup !== undefined && object.recordGroup !== null)
      ? RecordGroup.fromPartial(object.recordGroup)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseRecordGroup(): RecordGroup {
  return {
    id: "",
    type: 0,
    title: "",
    isDefault: false,
    publicId: "",
    color: "",
    defaultRole: 0,
    priority: 0,
    worker: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const RecordGroup: MessageFns<RecordGroup> = {
  encode(message: RecordGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.isDefault !== false) {
      writer.uint32(32).bool(message.isDefault);
    }
    if (message.publicId !== "") {
      writer.uint32(42).string(message.publicId);
    }
    if (message.color !== "") {
      writer.uint32(50).string(message.color);
    }
    if (message.defaultRole !== 0) {
      writer.uint32(56).int32(message.defaultRole);
    }
    if (message.priority !== 0) {
      writer.uint32(240).uint64(message.priority);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.publicId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.defaultRole = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.priority = longToNumber(reader.uint64());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordGroup {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? recordGroup_RecordGroupTypeFromJSON(object.type) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      publicId: isSet(object.publicId) ? globalThis.String(object.publicId) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      defaultRole: isSet(object.defaultRole) ? recordGroup_RecordGroupRoleFromJSON(object.defaultRole) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: RecordGroup): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = recordGroup_RecordGroupTypeToJSON(message.type);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.publicId !== "") {
      obj.publicId = message.publicId;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.defaultRole !== 0) {
      obj.defaultRole = recordGroup_RecordGroupRoleToJSON(message.defaultRole);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordGroup>, I>>(base?: I): RecordGroup {
    return RecordGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordGroup>, I>>(object: I): RecordGroup {
    const message = createBaseRecordGroup();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.title = object.title ?? "";
    message.isDefault = object.isDefault ?? false;
    message.publicId = object.publicId ?? "";
    message.color = object.color ?? "";
    message.defaultRole = object.defaultRole ?? 0;
    message.priority = object.priority ?? 0;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseWorkerRecordGroup(): WorkerRecordGroup {
  return {
    id: "",
    publicId: "",
    role: 0,
    priority: 0,
    worker: undefined,
    recordGroup: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const WorkerRecordGroup: MessageFns<WorkerRecordGroup> = {
  encode(message: WorkerRecordGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.publicId !== "") {
      writer.uint32(18).string(message.publicId);
    }
    if (message.role !== 0) {
      writer.uint32(24).int32(message.role);
    }
    if (message.priority !== 0) {
      writer.uint32(32).uint64(message.priority);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.recordGroup !== undefined) {
      RecordGroup.encode(message.recordGroup, writer.uint32(410).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerRecordGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRecordGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.priority = longToNumber(reader.uint64());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.recordGroup = RecordGroup.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerRecordGroup {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      publicId: isSet(object.publicId) ? globalThis.String(object.publicId) : "",
      role: isSet(object.role) ? workerRecordGroup_RecordGroupRoleFromJSON(object.role) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      recordGroup: isSet(object.recordGroup) ? RecordGroup.fromJSON(object.recordGroup) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: WorkerRecordGroup): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.publicId !== "") {
      obj.publicId = message.publicId;
    }
    if (message.role !== 0) {
      obj.role = workerRecordGroup_RecordGroupRoleToJSON(message.role);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.recordGroup !== undefined) {
      obj.recordGroup = RecordGroup.toJSON(message.recordGroup);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerRecordGroup>, I>>(base?: I): WorkerRecordGroup {
    return WorkerRecordGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerRecordGroup>, I>>(object: I): WorkerRecordGroup {
    const message = createBaseWorkerRecordGroup();
    message.id = object.id ?? "";
    message.publicId = object.publicId ?? "";
    message.role = object.role ?? 0;
    message.priority = object.priority ?? 0;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.recordGroup = (object.recordGroup !== undefined && object.recordGroup !== null)
      ? RecordGroup.fromPartial(object.recordGroup)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseSuccessResponse(): SuccessResponse {
  return { isSuccess: false };
}

export const SuccessResponse: MessageFns<SuccessResponse> = {
  encode(message: SuccessResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSuccess !== false) {
      writer.uint32(8).bool(message.isSuccess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuccessResponse {
    return { isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false };
  },

  toJSON(message: SuccessResponse): unknown {
    const obj: any = {};
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuccessResponse>, I>>(base?: I): SuccessResponse {
    return SuccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuccessResponse>, I>>(object: I): SuccessResponse {
    const message = createBaseSuccessResponse();
    message.isSuccess = object.isSuccess ?? false;
    return message;
  },
};

function createBaseSystemConfig(): SystemConfig {
  return { id: "", type: 0, value: "", worker: undefined, createdAt: 0, updatedAt: 0 };
}

export const SystemConfig: MessageFns<SystemConfig> = {
  encode(message: SystemConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemConfig {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? systemConfig_SystemConfigTypeFromJSON(object.type) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: SystemConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = systemConfig_SystemConfigTypeToJSON(message.type);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemConfig>, I>>(base?: I): SystemConfig {
    return SystemConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemConfig>, I>>(object: I): SystemConfig {
    const message = createBaseSystemConfig();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.value = object.value ?? "";
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOver(): TurnOver {
  return { id: "", name: "", startedAt: undefined, endedAt: undefined, worker: undefined, createdAt: 0, updatedAt: 0 };
}

export const TurnOver: MessageFns<TurnOver> = {
  encode(message: TurnOver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(24).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(32).uint64(message.endedAt);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOver {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOver): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOver>, I>>(base?: I): TurnOver {
    return TurnOver.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOver>, I>>(object: I): TurnOver {
    const message = createBaseTurnOver();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOverDetail(): TurnOverDetail {
  return {
    id: "",
    name: "",
    startedAt: undefined,
    endedAt: undefined,
    worker: undefined,
    turnOverGoal: undefined,
    turnOverChallenge: undefined,
    turnOverRetrospective: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const TurnOverDetail: MessageFns<TurnOverDetail> = {
  encode(message: TurnOverDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(24).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(32).uint64(message.endedAt);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.turnOverGoal !== undefined) {
      TurnOverGoalDetail.encode(message.turnOverGoal, writer.uint32(410).fork()).join();
    }
    if (message.turnOverChallenge !== undefined) {
      TurnOverChallengeDetail.encode(message.turnOverChallenge, writer.uint32(418).fork()).join();
    }
    if (message.turnOverRetrospective !== undefined) {
      TurnOverRetrospectiveDetail.encode(message.turnOverRetrospective, writer.uint32(426).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOverDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOverDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.turnOverGoal = TurnOverGoalDetail.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.turnOverChallenge = TurnOverChallengeDetail.decode(reader, reader.uint32());
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.turnOverRetrospective = TurnOverRetrospectiveDetail.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOverDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      turnOverGoal: isSet(object.turnOverGoal) ? TurnOverGoalDetail.fromJSON(object.turnOverGoal) : undefined,
      turnOverChallenge: isSet(object.turnOverChallenge)
        ? TurnOverChallengeDetail.fromJSON(object.turnOverChallenge)
        : undefined,
      turnOverRetrospective: isSet(object.turnOverRetrospective)
        ? TurnOverRetrospectiveDetail.fromJSON(object.turnOverRetrospective)
        : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOverDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.turnOverGoal !== undefined) {
      obj.turnOverGoal = TurnOverGoalDetail.toJSON(message.turnOverGoal);
    }
    if (message.turnOverChallenge !== undefined) {
      obj.turnOverChallenge = TurnOverChallengeDetail.toJSON(message.turnOverChallenge);
    }
    if (message.turnOverRetrospective !== undefined) {
      obj.turnOverRetrospective = TurnOverRetrospectiveDetail.toJSON(message.turnOverRetrospective);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOverDetail>, I>>(base?: I): TurnOverDetail {
    return TurnOverDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOverDetail>, I>>(object: I): TurnOverDetail {
    const message = createBaseTurnOverDetail();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.turnOverGoal = (object.turnOverGoal !== undefined && object.turnOverGoal !== null)
      ? TurnOverGoalDetail.fromPartial(object.turnOverGoal)
      : undefined;
    message.turnOverChallenge = (object.turnOverChallenge !== undefined && object.turnOverChallenge !== null)
      ? TurnOverChallengeDetail.fromPartial(object.turnOverChallenge)
      : undefined;
    message.turnOverRetrospective =
      (object.turnOverRetrospective !== undefined && object.turnOverRetrospective !== null)
        ? TurnOverRetrospectiveDetail.fromPartial(object.turnOverRetrospective)
        : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOverGoal(): TurnOverGoal {
  return { id: "", reason: "", goal: "", turnOver: undefined, createdAt: 0, updatedAt: 0 };
}

export const TurnOverGoal: MessageFns<TurnOverGoal> = {
  encode(message: TurnOverGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.goal !== "") {
      writer.uint32(26).string(message.goal);
    }
    if (message.turnOver !== undefined) {
      TurnOver.encode(message.turnOver, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOverGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOverGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.turnOver = TurnOver.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOverGoal {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      turnOver: isSet(object.turnOver) ? TurnOver.fromJSON(object.turnOver) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOverGoal): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.turnOver !== undefined) {
      obj.turnOver = TurnOver.toJSON(message.turnOver);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOverGoal>, I>>(base?: I): TurnOverGoal {
    return TurnOverGoal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOverGoal>, I>>(object: I): TurnOverGoal {
    const message = createBaseTurnOverGoal();
    message.id = object.id ?? "";
    message.reason = object.reason ?? "";
    message.goal = object.goal ?? "";
    message.turnOver = (object.turnOver !== undefined && object.turnOver !== null)
      ? TurnOver.fromPartial(object.turnOver)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOverGoalDetail(): TurnOverGoalDetail {
  return {
    id: "",
    reason: "",
    goal: "",
    selfIntroductions: [],
    interviewQuestions: [],
    checkList: [],
    memos: [],
    attachments: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const TurnOverGoalDetail: MessageFns<TurnOverGoalDetail> = {
  encode(message: TurnOverGoalDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.goal !== "") {
      writer.uint32(26).string(message.goal);
    }
    for (const v of message.selfIntroductions) {
      SelfIntroduction.encode(v!, writer.uint32(402).fork()).join();
    }
    for (const v of message.interviewQuestions) {
      InterviewQuestion.encode(v!, writer.uint32(410).fork()).join();
    }
    for (const v of message.checkList) {
      CheckList.encode(v!, writer.uint32(418).fork()).join();
    }
    for (const v of message.memos) {
      Memo.encode(v!, writer.uint32(426).fork()).join();
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(434).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOverGoalDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOverGoalDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.selfIntroductions.push(SelfIntroduction.decode(reader, reader.uint32()));
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.interviewQuestions.push(InterviewQuestion.decode(reader, reader.uint32()));
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.checkList.push(CheckList.decode(reader, reader.uint32()));
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.memos.push(Memo.decode(reader, reader.uint32()));
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOverGoalDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      selfIntroductions: globalThis.Array.isArray(object?.selfIntroductions)
        ? object.selfIntroductions.map((e: any) => SelfIntroduction.fromJSON(e))
        : [],
      interviewQuestions: globalThis.Array.isArray(object?.interviewQuestions)
        ? object.interviewQuestions.map((e: any) => InterviewQuestion.fromJSON(e))
        : [],
      checkList: globalThis.Array.isArray(object?.checkList)
        ? object.checkList.map((e: any) => CheckList.fromJSON(e))
        : [],
      memos: globalThis.Array.isArray(object?.memos) ? object.memos.map((e: any) => Memo.fromJSON(e)) : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOverGoalDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.selfIntroductions?.length) {
      obj.selfIntroductions = message.selfIntroductions.map((e) => SelfIntroduction.toJSON(e));
    }
    if (message.interviewQuestions?.length) {
      obj.interviewQuestions = message.interviewQuestions.map((e) => InterviewQuestion.toJSON(e));
    }
    if (message.checkList?.length) {
      obj.checkList = message.checkList.map((e) => CheckList.toJSON(e));
    }
    if (message.memos?.length) {
      obj.memos = message.memos.map((e) => Memo.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOverGoalDetail>, I>>(base?: I): TurnOverGoalDetail {
    return TurnOverGoalDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOverGoalDetail>, I>>(object: I): TurnOverGoalDetail {
    const message = createBaseTurnOverGoalDetail();
    message.id = object.id ?? "";
    message.reason = object.reason ?? "";
    message.goal = object.goal ?? "";
    message.selfIntroductions = object.selfIntroductions?.map((e) => SelfIntroduction.fromPartial(e)) || [];
    message.interviewQuestions = object.interviewQuestions?.map((e) => InterviewQuestion.fromPartial(e)) || [];
    message.checkList = object.checkList?.map((e) => CheckList.fromPartial(e)) || [];
    message.memos = object.memos?.map((e) => Memo.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseSelfIntroduction(): SelfIntroduction {
  return {
    id: "",
    question: "",
    content: "",
    isVisible: false,
    priority: 0,
    turnOver: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const SelfIntroduction: MessageFns<SelfIntroduction> = {
  encode(message: SelfIntroduction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.turnOver !== undefined) {
      TurnOver.encode(message.turnOver, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelfIntroduction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelfIntroduction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.turnOver = TurnOver.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelfIntroduction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      turnOver: isSet(object.turnOver) ? TurnOver.fromJSON(object.turnOver) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: SelfIntroduction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.turnOver !== undefined) {
      obj.turnOver = TurnOver.toJSON(message.turnOver);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelfIntroduction>, I>>(base?: I): SelfIntroduction {
    return SelfIntroduction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelfIntroduction>, I>>(object: I): SelfIntroduction {
    const message = createBaseSelfIntroduction();
    message.id = object.id ?? "";
    message.question = object.question ?? "";
    message.content = object.content ?? "";
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.turnOver = (object.turnOver !== undefined && object.turnOver !== null)
      ? TurnOver.fromPartial(object.turnOver)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseInterviewQuestion(): InterviewQuestion {
  return {
    id: "",
    question: "",
    answer: "",
    isVisible: false,
    priority: 0,
    turnOver: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const InterviewQuestion: MessageFns<InterviewQuestion> = {
  encode(message: InterviewQuestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    if (message.answer !== "") {
      writer.uint32(26).string(message.answer);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.turnOver !== undefined) {
      TurnOver.encode(message.turnOver, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterviewQuestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterviewQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.answer = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.turnOver = TurnOver.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterviewQuestion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      turnOver: isSet(object.turnOver) ? TurnOver.fromJSON(object.turnOver) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: InterviewQuestion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.turnOver !== undefined) {
      obj.turnOver = TurnOver.toJSON(message.turnOver);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InterviewQuestion>, I>>(base?: I): InterviewQuestion {
    return InterviewQuestion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InterviewQuestion>, I>>(object: I): InterviewQuestion {
    const message = createBaseInterviewQuestion();
    message.id = object.id ?? "";
    message.question = object.question ?? "";
    message.answer = object.answer ?? "";
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.turnOver = (object.turnOver !== undefined && object.turnOver !== null)
      ? TurnOver.fromPartial(object.turnOver)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseCheckList(): CheckList {
  return {
    id: "",
    checked: false,
    content: "",
    isVisible: false,
    priority: 0,
    turnOver: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const CheckList: MessageFns<CheckList> = {
  encode(message: CheckList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.checked !== false) {
      writer.uint32(16).bool(message.checked);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.turnOver !== undefined) {
      TurnOver.encode(message.turnOver, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.checked = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.turnOver = TurnOver.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckList {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      checked: isSet(object.checked) ? globalThis.Boolean(object.checked) : false,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      turnOver: isSet(object.turnOver) ? TurnOver.fromJSON(object.turnOver) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: CheckList): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.checked !== false) {
      obj.checked = message.checked;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.turnOver !== undefined) {
      obj.turnOver = TurnOver.toJSON(message.turnOver);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckList>, I>>(base?: I): CheckList {
    return CheckList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckList>, I>>(object: I): CheckList {
    const message = createBaseCheckList();
    message.id = object.id ?? "";
    message.checked = object.checked ?? false;
    message.content = object.content ?? "";
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.turnOver = (object.turnOver !== undefined && object.turnOver !== null)
      ? TurnOver.fromPartial(object.turnOver)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOverChallenge(): TurnOverChallenge {
  return { id: "", turnOver: undefined, createdAt: 0, updatedAt: 0 };
}

export const TurnOverChallenge: MessageFns<TurnOverChallenge> = {
  encode(message: TurnOverChallenge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.turnOver !== undefined) {
      TurnOver.encode(message.turnOver, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOverChallenge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOverChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.turnOver = TurnOver.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOverChallenge {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      turnOver: isSet(object.turnOver) ? TurnOver.fromJSON(object.turnOver) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOverChallenge): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.turnOver !== undefined) {
      obj.turnOver = TurnOver.toJSON(message.turnOver);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOverChallenge>, I>>(base?: I): TurnOverChallenge {
    return TurnOverChallenge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOverChallenge>, I>>(object: I): TurnOverChallenge {
    const message = createBaseTurnOverChallenge();
    message.id = object.id ?? "";
    message.turnOver = (object.turnOver !== undefined && object.turnOver !== null)
      ? TurnOver.fromPartial(object.turnOver)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOverChallengeDetail(): TurnOverChallengeDetail {
  return { id: "", jobApplications: [], memos: [], attachments: [], createdAt: 0, updatedAt: 0 };
}

export const TurnOverChallengeDetail: MessageFns<TurnOverChallengeDetail> = {
  encode(message: TurnOverChallengeDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.jobApplications) {
      JobApplicationDetail.encode(v!, writer.uint32(402).fork()).join();
    }
    for (const v of message.memos) {
      Memo.encode(v!, writer.uint32(410).fork()).join();
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(418).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOverChallengeDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOverChallengeDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.jobApplications.push(JobApplicationDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.memos.push(Memo.decode(reader, reader.uint32()));
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOverChallengeDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      jobApplications: globalThis.Array.isArray(object?.jobApplications)
        ? object.jobApplications.map((e: any) => JobApplicationDetail.fromJSON(e))
        : [],
      memos: globalThis.Array.isArray(object?.memos) ? object.memos.map((e: any) => Memo.fromJSON(e)) : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOverChallengeDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.jobApplications?.length) {
      obj.jobApplications = message.jobApplications.map((e) => JobApplicationDetail.toJSON(e));
    }
    if (message.memos?.length) {
      obj.memos = message.memos.map((e) => Memo.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOverChallengeDetail>, I>>(base?: I): TurnOverChallengeDetail {
    return TurnOverChallengeDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOverChallengeDetail>, I>>(object: I): TurnOverChallengeDetail {
    const message = createBaseTurnOverChallengeDetail();
    message.id = object.id ?? "";
    message.jobApplications = object.jobApplications?.map((e) => JobApplicationDetail.fromPartial(e)) || [];
    message.memos = object.memos?.map((e) => Memo.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseJobApplication(): JobApplication {
  return {
    id: "",
    name: "",
    position: "",
    jobPostingTitle: "",
    jobPostingUrl: "",
    startedAt: undefined,
    endedAt: undefined,
    applicationSource: "",
    memo: "",
    status: 0,
    isVisible: false,
    priority: 0,
    turnOver: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const JobApplication: MessageFns<JobApplication> = {
  encode(message: JobApplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.position !== "") {
      writer.uint32(26).string(message.position);
    }
    if (message.jobPostingTitle !== "") {
      writer.uint32(34).string(message.jobPostingTitle);
    }
    if (message.jobPostingUrl !== "") {
      writer.uint32(42).string(message.jobPostingUrl);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(48).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(56).uint64(message.endedAt);
    }
    if (message.applicationSource !== "") {
      writer.uint32(66).string(message.applicationSource);
    }
    if (message.memo !== "") {
      writer.uint32(74).string(message.memo);
    }
    if (message.status !== 0) {
      writer.uint32(232).int32(message.status);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.turnOver !== undefined) {
      TurnOver.encode(message.turnOver, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobApplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jobPostingTitle = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.jobPostingUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.applicationSource = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.turnOver = TurnOver.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobApplication {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      jobPostingTitle: isSet(object.jobPostingTitle) ? globalThis.String(object.jobPostingTitle) : "",
      jobPostingUrl: isSet(object.jobPostingUrl) ? globalThis.String(object.jobPostingUrl) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      applicationSource: isSet(object.applicationSource) ? globalThis.String(object.applicationSource) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      status: isSet(object.status) ? jobApplication_JobApplicationStatusFromJSON(object.status) : 0,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      turnOver: isSet(object.turnOver) ? TurnOver.fromJSON(object.turnOver) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: JobApplication): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.jobPostingTitle !== "") {
      obj.jobPostingTitle = message.jobPostingTitle;
    }
    if (message.jobPostingUrl !== "") {
      obj.jobPostingUrl = message.jobPostingUrl;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.applicationSource !== "") {
      obj.applicationSource = message.applicationSource;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.status !== 0) {
      obj.status = jobApplication_JobApplicationStatusToJSON(message.status);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.turnOver !== undefined) {
      obj.turnOver = TurnOver.toJSON(message.turnOver);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JobApplication>, I>>(base?: I): JobApplication {
    return JobApplication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JobApplication>, I>>(object: I): JobApplication {
    const message = createBaseJobApplication();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.position = object.position ?? "";
    message.jobPostingTitle = object.jobPostingTitle ?? "";
    message.jobPostingUrl = object.jobPostingUrl ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.applicationSource = object.applicationSource ?? "";
    message.memo = object.memo ?? "";
    message.status = object.status ?? 0;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.turnOver = (object.turnOver !== undefined && object.turnOver !== null)
      ? TurnOver.fromPartial(object.turnOver)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseJobApplicationDetail(): JobApplicationDetail {
  return {
    id: "",
    name: "",
    position: "",
    jobPostingTitle: "",
    jobPostingUrl: "",
    startedAt: undefined,
    endedAt: undefined,
    applicationSource: "",
    memo: "",
    status: 0,
    isVisible: false,
    priority: 0,
    applicationStages: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const JobApplicationDetail: MessageFns<JobApplicationDetail> = {
  encode(message: JobApplicationDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.position !== "") {
      writer.uint32(26).string(message.position);
    }
    if (message.jobPostingTitle !== "") {
      writer.uint32(34).string(message.jobPostingTitle);
    }
    if (message.jobPostingUrl !== "") {
      writer.uint32(42).string(message.jobPostingUrl);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(48).uint64(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      writer.uint32(56).uint64(message.endedAt);
    }
    if (message.applicationSource !== "") {
      writer.uint32(66).string(message.applicationSource);
    }
    if (message.memo !== "") {
      writer.uint32(74).string(message.memo);
    }
    if (message.status !== 0) {
      writer.uint32(232).int32(message.status);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    for (const v of message.applicationStages) {
      ApplicationStage.encode(v!, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobApplicationDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobApplicationDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jobPostingTitle = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.jobPostingUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.applicationSource = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.applicationStages.push(ApplicationStage.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobApplicationDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      jobPostingTitle: isSet(object.jobPostingTitle) ? globalThis.String(object.jobPostingTitle) : "",
      jobPostingUrl: isSet(object.jobPostingUrl) ? globalThis.String(object.jobPostingUrl) : "",
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : undefined,
      applicationSource: isSet(object.applicationSource) ? globalThis.String(object.applicationSource) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      status: isSet(object.status) ? jobApplication_JobApplicationStatusFromJSON(object.status) : 0,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      applicationStages: globalThis.Array.isArray(object?.applicationStages)
        ? object.applicationStages.map((e: any) => ApplicationStage.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: JobApplicationDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.jobPostingTitle !== "") {
      obj.jobPostingTitle = message.jobPostingTitle;
    }
    if (message.jobPostingUrl !== "") {
      obj.jobPostingUrl = message.jobPostingUrl;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.applicationSource !== "") {
      obj.applicationSource = message.applicationSource;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.status !== 0) {
      obj.status = jobApplication_JobApplicationStatusToJSON(message.status);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.applicationStages?.length) {
      obj.applicationStages = message.applicationStages.map((e) => ApplicationStage.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JobApplicationDetail>, I>>(base?: I): JobApplicationDetail {
    return JobApplicationDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JobApplicationDetail>, I>>(object: I): JobApplicationDetail {
    const message = createBaseJobApplicationDetail();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.position = object.position ?? "";
    message.jobPostingTitle = object.jobPostingTitle ?? "";
    message.jobPostingUrl = object.jobPostingUrl ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.applicationSource = object.applicationSource ?? "";
    message.memo = object.memo ?? "";
    message.status = object.status ?? 0;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.applicationStages = object.applicationStages?.map((e) => ApplicationStage.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseApplicationStage(): ApplicationStage {
  return {
    id: "",
    name: "",
    status: 0,
    startedAt: undefined,
    memo: "",
    isVisible: false,
    priority: 0,
    jobApplication: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const ApplicationStage: MessageFns<ApplicationStage> = {
  encode(message: ApplicationStage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(32).uint64(message.startedAt);
    }
    if (message.memo !== "") {
      writer.uint32(42).string(message.memo);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.jobApplication !== undefined) {
      JobApplication.encode(message.jobApplication, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationStage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.jobApplication = JobApplication.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationStage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? applicationStage_ApplicationStageStatusFromJSON(object.status) : 0,
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      jobApplication: isSet(object.jobApplication) ? JobApplication.fromJSON(object.jobApplication) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: ApplicationStage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== 0) {
      obj.status = applicationStage_ApplicationStageStatusToJSON(message.status);
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.jobApplication !== undefined) {
      obj.jobApplication = JobApplication.toJSON(message.jobApplication);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationStage>, I>>(base?: I): ApplicationStage {
    return ApplicationStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationStage>, I>>(object: I): ApplicationStage {
    const message = createBaseApplicationStage();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.status = object.status ?? 0;
    message.startedAt = object.startedAt ?? undefined;
    message.memo = object.memo ?? "";
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.jobApplication = (object.jobApplication !== undefined && object.jobApplication !== null)
      ? JobApplication.fromPartial(object.jobApplication)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOverRetrospective(): TurnOverRetrospective {
  return {
    id: "",
    name: "",
    salary: 0,
    position: "",
    jobTitle: "",
    rank: "",
    department: "",
    reason: "",
    score: 0,
    reviewSummary: "",
    joinedAt: undefined,
    workType: "",
    employmentType: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const TurnOverRetrospective: MessageFns<TurnOverRetrospective> = {
  encode(message: TurnOverRetrospective, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.salary !== 0) {
      writer.uint32(24).uint32(message.salary);
    }
    if (message.position !== "") {
      writer.uint32(34).string(message.position);
    }
    if (message.jobTitle !== "") {
      writer.uint32(42).string(message.jobTitle);
    }
    if (message.rank !== "") {
      writer.uint32(50).string(message.rank);
    }
    if (message.department !== "") {
      writer.uint32(58).string(message.department);
    }
    if (message.reason !== "") {
      writer.uint32(66).string(message.reason);
    }
    if (message.score !== 0) {
      writer.uint32(72).uint32(message.score);
    }
    if (message.reviewSummary !== "") {
      writer.uint32(82).string(message.reviewSummary);
    }
    if (message.joinedAt !== undefined) {
      writer.uint32(88).uint64(message.joinedAt);
    }
    if (message.workType !== "") {
      writer.uint32(98).string(message.workType);
    }
    if (message.employmentType !== undefined) {
      writer.uint32(104).int32(message.employmentType);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOverRetrospective {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOverRetrospective();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.salary = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.jobTitle = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rank = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.department = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.reviewSummary = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.joinedAt = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.workType = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.employmentType = reader.int32() as any;
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOverRetrospective {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      salary: isSet(object.salary) ? globalThis.Number(object.salary) : 0,
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      jobTitle: isSet(object.jobTitle) ? globalThis.String(object.jobTitle) : "",
      rank: isSet(object.rank) ? globalThis.String(object.rank) : "",
      department: isSet(object.department) ? globalThis.String(object.department) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      reviewSummary: isSet(object.reviewSummary) ? globalThis.String(object.reviewSummary) : "",
      joinedAt: isSet(object.joinedAt) ? globalThis.Number(object.joinedAt) : undefined,
      workType: isSet(object.workType) ? globalThis.String(object.workType) : "",
      employmentType: isSet(object.employmentType)
        ? turnOverRetrospective_EmploymentTypeFromJSON(object.employmentType)
        : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOverRetrospective): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.salary !== 0) {
      obj.salary = Math.round(message.salary);
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.jobTitle !== "") {
      obj.jobTitle = message.jobTitle;
    }
    if (message.rank !== "") {
      obj.rank = message.rank;
    }
    if (message.department !== "") {
      obj.department = message.department;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.reviewSummary !== "") {
      obj.reviewSummary = message.reviewSummary;
    }
    if (message.joinedAt !== undefined) {
      obj.joinedAt = Math.round(message.joinedAt);
    }
    if (message.workType !== "") {
      obj.workType = message.workType;
    }
    if (message.employmentType !== undefined) {
      obj.employmentType = turnOverRetrospective_EmploymentTypeToJSON(message.employmentType);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOverRetrospective>, I>>(base?: I): TurnOverRetrospective {
    return TurnOverRetrospective.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOverRetrospective>, I>>(object: I): TurnOverRetrospective {
    const message = createBaseTurnOverRetrospective();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.salary = object.salary ?? 0;
    message.position = object.position ?? "";
    message.jobTitle = object.jobTitle ?? "";
    message.rank = object.rank ?? "";
    message.department = object.department ?? "";
    message.reason = object.reason ?? "";
    message.score = object.score ?? 0;
    message.reviewSummary = object.reviewSummary ?? "";
    message.joinedAt = object.joinedAt ?? undefined;
    message.workType = object.workType ?? "";
    message.employmentType = object.employmentType ?? undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTurnOverRetrospectiveDetail(): TurnOverRetrospectiveDetail {
  return {
    id: "",
    name: "",
    salary: 0,
    position: "",
    jobTitle: "",
    rank: "",
    department: "",
    reason: "",
    score: 0,
    reviewSummary: "",
    joinedAt: undefined,
    workType: "",
    employmentType: undefined,
    memos: [],
    attachments: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const TurnOverRetrospectiveDetail: MessageFns<TurnOverRetrospectiveDetail> = {
  encode(message: TurnOverRetrospectiveDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.salary !== 0) {
      writer.uint32(24).uint32(message.salary);
    }
    if (message.position !== "") {
      writer.uint32(34).string(message.position);
    }
    if (message.jobTitle !== "") {
      writer.uint32(42).string(message.jobTitle);
    }
    if (message.rank !== "") {
      writer.uint32(50).string(message.rank);
    }
    if (message.department !== "") {
      writer.uint32(58).string(message.department);
    }
    if (message.reason !== "") {
      writer.uint32(66).string(message.reason);
    }
    if (message.score !== 0) {
      writer.uint32(72).uint32(message.score);
    }
    if (message.reviewSummary !== "") {
      writer.uint32(82).string(message.reviewSummary);
    }
    if (message.joinedAt !== undefined) {
      writer.uint32(88).uint64(message.joinedAt);
    }
    if (message.workType !== "") {
      writer.uint32(98).string(message.workType);
    }
    if (message.employmentType !== undefined) {
      writer.uint32(104).int32(message.employmentType);
    }
    for (const v of message.memos) {
      Memo.encode(v!, writer.uint32(410).fork()).join();
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(418).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnOverRetrospectiveDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnOverRetrospectiveDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.salary = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.jobTitle = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rank = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.department = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.reviewSummary = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.joinedAt = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.workType = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.employmentType = reader.int32() as any;
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.memos.push(Memo.decode(reader, reader.uint32()));
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnOverRetrospectiveDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      salary: isSet(object.salary) ? globalThis.Number(object.salary) : 0,
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      jobTitle: isSet(object.jobTitle) ? globalThis.String(object.jobTitle) : "",
      rank: isSet(object.rank) ? globalThis.String(object.rank) : "",
      department: isSet(object.department) ? globalThis.String(object.department) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      reviewSummary: isSet(object.reviewSummary) ? globalThis.String(object.reviewSummary) : "",
      joinedAt: isSet(object.joinedAt) ? globalThis.Number(object.joinedAt) : undefined,
      workType: isSet(object.workType) ? globalThis.String(object.workType) : "",
      employmentType: isSet(object.employmentType)
        ? turnOverRetrospectiveDetail_EmploymentTypeFromJSON(object.employmentType)
        : undefined,
      memos: globalThis.Array.isArray(object?.memos) ? object.memos.map((e: any) => Memo.fromJSON(e)) : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TurnOverRetrospectiveDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.salary !== 0) {
      obj.salary = Math.round(message.salary);
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.jobTitle !== "") {
      obj.jobTitle = message.jobTitle;
    }
    if (message.rank !== "") {
      obj.rank = message.rank;
    }
    if (message.department !== "") {
      obj.department = message.department;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.reviewSummary !== "") {
      obj.reviewSummary = message.reviewSummary;
    }
    if (message.joinedAt !== undefined) {
      obj.joinedAt = Math.round(message.joinedAt);
    }
    if (message.workType !== "") {
      obj.workType = message.workType;
    }
    if (message.employmentType !== undefined) {
      obj.employmentType = turnOverRetrospectiveDetail_EmploymentTypeToJSON(message.employmentType);
    }
    if (message.memos?.length) {
      obj.memos = message.memos.map((e) => Memo.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnOverRetrospectiveDetail>, I>>(base?: I): TurnOverRetrospectiveDetail {
    return TurnOverRetrospectiveDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnOverRetrospectiveDetail>, I>>(object: I): TurnOverRetrospectiveDetail {
    const message = createBaseTurnOverRetrospectiveDetail();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.salary = object.salary ?? 0;
    message.position = object.position ?? "";
    message.jobTitle = object.jobTitle ?? "";
    message.rank = object.rank ?? "";
    message.department = object.department ?? "";
    message.reason = object.reason ?? "";
    message.score = object.score ?? 0;
    message.reviewSummary = object.reviewSummary ?? "";
    message.joinedAt = object.joinedAt ?? undefined;
    message.workType = object.workType ?? "";
    message.employmentType = object.employmentType ?? undefined;
    message.memos = object.memos?.map((e) => Memo.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseAttachment(): Attachment {
  return {
    id: "",
    type: undefined,
    category: 0,
    url: "",
    fileName: "",
    fileUrl: "",
    targetId: "",
    targetType: 0,
    isVisible: false,
    priority: 0,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Attachment: MessageFns<Attachment> = {
  encode(message: Attachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== undefined) {
      writer.uint32(16).int32(message.type);
    }
    if (message.category !== 0) {
      writer.uint32(24).int32(message.category);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (message.fileName !== "") {
      writer.uint32(42).string(message.fileName);
    }
    if (message.fileUrl !== "") {
      writer.uint32(50).string(message.fileUrl);
    }
    if (message.targetId !== "") {
      writer.uint32(58).string(message.targetId);
    }
    if (message.targetType !== 0) {
      writer.uint32(64).int32(message.targetType);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.targetId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.targetType = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attachment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? attachment_AttachmentTypeFromJSON(object.type) : undefined,
      category: isSet(object.category) ? attachment_AttachmentCategoryFromJSON(object.category) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      fileUrl: isSet(object.fileUrl) ? globalThis.String(object.fileUrl) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      targetType: isSet(object.targetType) ? attachment_AttachmentTargetTypeFromJSON(object.targetType) : 0,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Attachment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== undefined) {
      obj.type = attachment_AttachmentTypeToJSON(message.type);
    }
    if (message.category !== 0) {
      obj.category = attachment_AttachmentCategoryToJSON(message.category);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileUrl !== "") {
      obj.fileUrl = message.fileUrl;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.targetType !== 0) {
      obj.targetType = attachment_AttachmentTargetTypeToJSON(message.targetType);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attachment>, I>>(base?: I): Attachment {
    return Attachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attachment>, I>>(object: I): Attachment {
    const message = createBaseAttachment();
    message.id = object.id ?? "";
    message.type = object.type ?? undefined;
    message.category = object.category ?? 0;
    message.url = object.url ?? "";
    message.fileName = object.fileName ?? "";
    message.fileUrl = object.fileUrl ?? "";
    message.targetId = object.targetId ?? "";
    message.targetType = object.targetType ?? 0;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseMemo(): Memo {
  return {
    id: "",
    content: "",
    targetId: "",
    targetType: 0,
    isVisible: false,
    priority: 0,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Memo: MessageFns<Memo> = {
  encode(message: Memo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.targetId !== "") {
      writer.uint32(26).string(message.targetId);
    }
    if (message.targetType !== 0) {
      writer.uint32(32).int32(message.targetType);
    }
    if (message.isVisible !== false) {
      writer.uint32(240).bool(message.isVisible);
    }
    if (message.priority !== 0) {
      writer.uint32(248).uint32(message.priority);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Memo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.targetType = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.isVisible = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      targetType: isSet(object.targetType) ? memo_MemoTargetTypeFromJSON(object.targetType) : 0,
      isVisible: isSet(object.isVisible) ? globalThis.Boolean(object.isVisible) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Memo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.targetType !== 0) {
      obj.targetType = memo_MemoTargetTypeToJSON(message.targetType);
    }
    if (message.isVisible !== false) {
      obj.isVisible = message.isVisible;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo>, I>>(base?: I): Memo {
    return Memo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo>, I>>(object: I): Memo {
    const message = createBaseMemo();
    message.id = object.id ?? "";
    message.content = object.content ?? "";
    message.targetId = object.targetId ?? "";
    message.targetType = object.targetType ?? 0;
    message.isVisible = object.isVisible ?? false;
    message.priority = object.priority ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseNotice(): Notice {
  return { id: "", title: "", content: "", isPinned: false, createdAt: 0, updatedAt: 0 };
}

export const Notice: MessageFns<Notice> = {
  encode(message: Notice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.isPinned !== false) {
      writer.uint32(32).bool(message.isPinned);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isPinned = reader.bool();
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notice {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      isPinned: isSet(object.isPinned) ? globalThis.Boolean(object.isPinned) : false,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Notice): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isPinned !== false) {
      obj.isPinned = message.isPinned;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notice>, I>>(base?: I): Notice {
    return Notice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notice>, I>>(object: I): Notice {
    const message = createBaseNotice();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.isPinned = object.isPinned ?? false;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBasePlan(): Plan {
  return {
    id: "",
    name: "",
    type: 0,
    price: 0,
    currency: "",
    priority: 0,
    description: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Plan: MessageFns<Plan> = {
  encode(message: Plan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.price !== 0) {
      writer.uint32(32).uint64(message.price);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    if (message.description !== undefined) {
      writer.uint32(58).string(message.description);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Plan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.price = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Plan {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? plan_PlanTypeFromJSON(object.type) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Plan): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = plan_PlanTypeToJSON(message.type);
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Plan>, I>>(base?: I): Plan {
    return Plan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Plan>, I>>(object: I): Plan {
    const message = createBasePlan();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.price = object.price ?? 0;
    message.currency = object.currency ?? "";
    message.priority = object.priority ?? 0;
    message.description = object.description ?? undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBasePlanSubscription(): PlanSubscription {
  return {
    id: "",
    durationMonths: "",
    totalPrice: 0,
    monthlyEquivalent: 0,
    savingsAmount: 0,
    discountRate: 0,
    priority: 0,
    plan: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const PlanSubscription: MessageFns<PlanSubscription> = {
  encode(message: PlanSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.durationMonths !== "") {
      writer.uint32(18).string(message.durationMonths);
    }
    if (message.totalPrice !== 0) {
      writer.uint32(24).uint64(message.totalPrice);
    }
    if (message.monthlyEquivalent !== 0) {
      writer.uint32(32).uint64(message.monthlyEquivalent);
    }
    if (message.savingsAmount !== 0) {
      writer.uint32(40).uint64(message.savingsAmount);
    }
    if (message.discountRate !== 0) {
      writer.uint32(48).uint32(message.discountRate);
    }
    if (message.priority !== 0) {
      writer.uint32(56).uint32(message.priority);
    }
    if (message.plan !== undefined) {
      Plan.encode(message.plan, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlanSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.durationMonths = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalPrice = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.monthlyEquivalent = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.savingsAmount = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.discountRate = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.plan = Plan.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlanSubscription {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      durationMonths: isSet(object.durationMonths) ? globalThis.String(object.durationMonths) : "",
      totalPrice: isSet(object.totalPrice) ? globalThis.Number(object.totalPrice) : 0,
      monthlyEquivalent: isSet(object.monthlyEquivalent) ? globalThis.Number(object.monthlyEquivalent) : 0,
      savingsAmount: isSet(object.savingsAmount) ? globalThis.Number(object.savingsAmount) : 0,
      discountRate: isSet(object.discountRate) ? globalThis.Number(object.discountRate) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      plan: isSet(object.plan) ? Plan.fromJSON(object.plan) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: PlanSubscription): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.durationMonths !== "") {
      obj.durationMonths = message.durationMonths;
    }
    if (message.totalPrice !== 0) {
      obj.totalPrice = Math.round(message.totalPrice);
    }
    if (message.monthlyEquivalent !== 0) {
      obj.monthlyEquivalent = Math.round(message.monthlyEquivalent);
    }
    if (message.savingsAmount !== 0) {
      obj.savingsAmount = Math.round(message.savingsAmount);
    }
    if (message.discountRate !== 0) {
      obj.discountRate = Math.round(message.discountRate);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.plan !== undefined) {
      obj.plan = Plan.toJSON(message.plan);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlanSubscription>, I>>(base?: I): PlanSubscription {
    return PlanSubscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlanSubscription>, I>>(object: I): PlanSubscription {
    const message = createBasePlanSubscription();
    message.id = object.id ?? "";
    message.durationMonths = object.durationMonths ?? "";
    message.totalPrice = object.totalPrice ?? 0;
    message.monthlyEquivalent = object.monthlyEquivalent ?? 0;
    message.savingsAmount = object.savingsAmount ?? 0;
    message.discountRate = object.discountRate ?? 0;
    message.priority = object.priority ?? 0;
    message.plan = (object.plan !== undefined && object.plan !== null) ? Plan.fromPartial(object.plan) : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseFeature(): Feature {
  return { id: "", name: "", domain: "", action: "", createdAt: 0, updatedAt: 0 };
}

export const Feature: MessageFns<Feature> = {
  encode(message: Feature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.domain !== "") {
      writer.uint32(26).string(message.domain);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Feature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Feature {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Feature): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Feature>, I>>(base?: I): Feature {
    return Feature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Feature>, I>>(object: I): Feature {
    const message = createBaseFeature();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.domain = object.domain ?? "";
    message.action = object.action ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseWorkerSubscription(): WorkerSubscription {
  return {
    id: "",
    planName: "",
    planType: 0,
    status: 0,
    startedAt: 0,
    endedAt: 0,
    cancelledAt: undefined,
    cancelReason: undefined,
    worker: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const WorkerSubscription: MessageFns<WorkerSubscription> = {
  encode(message: WorkerSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.planName !== "") {
      writer.uint32(18).string(message.planName);
    }
    if (message.planType !== 0) {
      writer.uint32(24).int32(message.planType);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.startedAt !== 0) {
      writer.uint32(40).uint64(message.startedAt);
    }
    if (message.endedAt !== 0) {
      writer.uint32(48).uint64(message.endedAt);
    }
    if (message.cancelledAt !== undefined) {
      writer.uint32(56).uint64(message.cancelledAt);
    }
    if (message.cancelReason !== undefined) {
      writer.uint32(66).string(message.cancelReason);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.planName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.planType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.startedAt = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.endedAt = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cancelledAt = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cancelReason = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerSubscription {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      planName: isSet(object.planName) ? globalThis.String(object.planName) : "",
      planType: isSet(object.planType) ? plan_PlanTypeFromJSON(object.planType) : 0,
      status: isSet(object.status) ? workerSubscription_SubscriptionStatusFromJSON(object.status) : 0,
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : 0,
      endedAt: isSet(object.endedAt) ? globalThis.Number(object.endedAt) : 0,
      cancelledAt: isSet(object.cancelledAt) ? globalThis.Number(object.cancelledAt) : undefined,
      cancelReason: isSet(object.cancelReason) ? globalThis.String(object.cancelReason) : undefined,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: WorkerSubscription): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.planName !== "") {
      obj.planName = message.planName;
    }
    if (message.planType !== 0) {
      obj.planType = plan_PlanTypeToJSON(message.planType);
    }
    if (message.status !== 0) {
      obj.status = workerSubscription_SubscriptionStatusToJSON(message.status);
    }
    if (message.startedAt !== 0) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.endedAt !== 0) {
      obj.endedAt = Math.round(message.endedAt);
    }
    if (message.cancelledAt !== undefined) {
      obj.cancelledAt = Math.round(message.cancelledAt);
    }
    if (message.cancelReason !== undefined) {
      obj.cancelReason = message.cancelReason;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerSubscription>, I>>(base?: I): WorkerSubscription {
    return WorkerSubscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerSubscription>, I>>(object: I): WorkerSubscription {
    const message = createBaseWorkerSubscription();
    message.id = object.id ?? "";
    message.planName = object.planName ?? "";
    message.planType = object.planType ?? 0;
    message.status = object.status ?? 0;
    message.startedAt = object.startedAt ?? 0;
    message.endedAt = object.endedAt ?? 0;
    message.cancelledAt = object.cancelledAt ?? undefined;
    message.cancelReason = object.cancelReason ?? undefined;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseWorkerFeatureUsage(): WorkerFeatureUsage {
  return {
    id: "",
    currentCount: 0,
    limitCount: undefined,
    lastUsedAt: 0,
    worker: undefined,
    createdAt: 0,
    updatedAt: 0,
  };
}

export const WorkerFeatureUsage: MessageFns<WorkerFeatureUsage> = {
  encode(message: WorkerFeatureUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.currentCount !== 0) {
      writer.uint32(16).uint32(message.currentCount);
    }
    if (message.limitCount !== undefined) {
      writer.uint32(24).uint32(message.limitCount);
    }
    if (message.lastUsedAt !== 0) {
      writer.uint32(32).uint64(message.lastUsedAt);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerFeatureUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerFeatureUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currentCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limitCount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastUsedAt = longToNumber(reader.uint64());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerFeatureUsage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      currentCount: isSet(object.currentCount) ? globalThis.Number(object.currentCount) : 0,
      limitCount: isSet(object.limitCount) ? globalThis.Number(object.limitCount) : undefined,
      lastUsedAt: isSet(object.lastUsedAt) ? globalThis.Number(object.lastUsedAt) : 0,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: WorkerFeatureUsage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.currentCount !== 0) {
      obj.currentCount = Math.round(message.currentCount);
    }
    if (message.limitCount !== undefined) {
      obj.limitCount = Math.round(message.limitCount);
    }
    if (message.lastUsedAt !== 0) {
      obj.lastUsedAt = Math.round(message.lastUsedAt);
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerFeatureUsage>, I>>(base?: I): WorkerFeatureUsage {
    return WorkerFeatureUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerFeatureUsage>, I>>(object: I): WorkerFeatureUsage {
    const message = createBaseWorkerFeatureUsage();
    message.id = object.id ?? "";
    message.currentCount = object.currentCount ?? 0;
    message.limitCount = object.limitCount ?? undefined;
    message.lastUsedAt = object.lastUsedAt ?? 0;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBasePlanFeature(): PlanFeature {
  return { id: "", plan: undefined, feature: undefined, limitCount: 0, description: "", createdAt: 0, updatedAt: 0 };
}

export const PlanFeature: MessageFns<PlanFeature> = {
  encode(message: PlanFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.plan !== undefined) {
      Plan.encode(message.plan, writer.uint32(402).fork()).join();
    }
    if (message.feature !== undefined) {
      Feature.encode(message.feature, writer.uint32(410).fork()).join();
    }
    if (message.limitCount !== 0) {
      writer.uint32(416).int32(message.limitCount);
    }
    if (message.description !== "") {
      writer.uint32(426).string(message.description);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlanFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.plan = Plan.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.feature = Feature.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.limitCount = reader.int32();
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlanFeature {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      plan: isSet(object.plan) ? Plan.fromJSON(object.plan) : undefined,
      feature: isSet(object.feature) ? Feature.fromJSON(object.feature) : undefined,
      limitCount: isSet(object.limitCount) ? globalThis.Number(object.limitCount) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: PlanFeature): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.plan !== undefined) {
      obj.plan = Plan.toJSON(message.plan);
    }
    if (message.feature !== undefined) {
      obj.feature = Feature.toJSON(message.feature);
    }
    if (message.limitCount !== 0) {
      obj.limitCount = Math.round(message.limitCount);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlanFeature>, I>>(base?: I): PlanFeature {
    return PlanFeature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlanFeature>, I>>(object: I): PlanFeature {
    const message = createBasePlanFeature();
    message.id = object.id ?? "";
    message.plan = (object.plan !== undefined && object.plan !== null) ? Plan.fromPartial(object.plan) : undefined;
    message.feature = (object.feature !== undefined && object.feature !== null)
      ? Feature.fromPartial(object.feature)
      : undefined;
    message.limitCount = object.limitCount ?? 0;
    message.description = object.description ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBasePayment(): Payment {
  return {
    id: "",
    amount: 0,
    currency: "",
    status: 0,
    paymentMethod: 0,
    paymentProvider: "",
    providerPaymentId: "",
    paidAt: undefined,
    refundedAt: undefined,
    refundAmount: 0,
    refundReason: undefined,
    failureReason: undefined,
    failureCode: undefined,
    metadataJson: undefined,
    worker: undefined,
    paymentTransactions: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const Payment: MessageFns<Payment> = {
  encode(message: Payment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(40).int32(message.paymentMethod);
    }
    if (message.paymentProvider !== "") {
      writer.uint32(50).string(message.paymentProvider);
    }
    if (message.providerPaymentId !== "") {
      writer.uint32(58).string(message.providerPaymentId);
    }
    if (message.paidAt !== undefined) {
      writer.uint32(64).uint64(message.paidAt);
    }
    if (message.refundedAt !== undefined) {
      writer.uint32(72).uint64(message.refundedAt);
    }
    if (message.refundAmount !== 0) {
      writer.uint32(80).int64(message.refundAmount);
    }
    if (message.refundReason !== undefined) {
      writer.uint32(90).string(message.refundReason);
    }
    if (message.failureReason !== undefined) {
      writer.uint32(98).string(message.failureReason);
    }
    if (message.failureCode !== undefined) {
      writer.uint32(106).string(message.failureCode);
    }
    if (message.metadataJson !== undefined) {
      writer.uint32(114).string(message.metadataJson);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(402).fork()).join();
    }
    for (const v of message.paymentTransactions) {
      PaymentTransaction.encode(v!, writer.uint32(410).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Payment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentProvider = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.providerPaymentId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.paidAt = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.refundedAt = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.refundAmount = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.refundReason = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.failureReason = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.failureCode = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.metadataJson = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.paymentTransactions.push(PaymentTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? payment_PaymentStatusFromJSON(object.status) : 0,
      paymentMethod: isSet(object.paymentMethod) ? payment_PaymentMethodFromJSON(object.paymentMethod) : 0,
      paymentProvider: isSet(object.paymentProvider) ? globalThis.String(object.paymentProvider) : "",
      providerPaymentId: isSet(object.providerPaymentId) ? globalThis.String(object.providerPaymentId) : "",
      paidAt: isSet(object.paidAt) ? globalThis.Number(object.paidAt) : undefined,
      refundedAt: isSet(object.refundedAt) ? globalThis.Number(object.refundedAt) : undefined,
      refundAmount: isSet(object.refundAmount) ? globalThis.Number(object.refundAmount) : 0,
      refundReason: isSet(object.refundReason) ? globalThis.String(object.refundReason) : undefined,
      failureReason: isSet(object.failureReason) ? globalThis.String(object.failureReason) : undefined,
      failureCode: isSet(object.failureCode) ? globalThis.String(object.failureCode) : undefined,
      metadataJson: isSet(object.metadataJson) ? globalThis.String(object.metadataJson) : undefined,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      paymentTransactions: globalThis.Array.isArray(object?.paymentTransactions)
        ? object.paymentTransactions.map((e: any) => PaymentTransaction.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Payment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = payment_PaymentStatusToJSON(message.status);
    }
    if (message.paymentMethod !== 0) {
      obj.paymentMethod = payment_PaymentMethodToJSON(message.paymentMethod);
    }
    if (message.paymentProvider !== "") {
      obj.paymentProvider = message.paymentProvider;
    }
    if (message.providerPaymentId !== "") {
      obj.providerPaymentId = message.providerPaymentId;
    }
    if (message.paidAt !== undefined) {
      obj.paidAt = Math.round(message.paidAt);
    }
    if (message.refundedAt !== undefined) {
      obj.refundedAt = Math.round(message.refundedAt);
    }
    if (message.refundAmount !== 0) {
      obj.refundAmount = Math.round(message.refundAmount);
    }
    if (message.refundReason !== undefined) {
      obj.refundReason = message.refundReason;
    }
    if (message.failureReason !== undefined) {
      obj.failureReason = message.failureReason;
    }
    if (message.failureCode !== undefined) {
      obj.failureCode = message.failureCode;
    }
    if (message.metadataJson !== undefined) {
      obj.metadataJson = message.metadataJson;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.paymentTransactions?.length) {
      obj.paymentTransactions = message.paymentTransactions.map((e) => PaymentTransaction.toJSON(e));
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payment>, I>>(base?: I): Payment {
    return Payment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payment>, I>>(object: I): Payment {
    const message = createBasePayment();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.paymentMethod = object.paymentMethod ?? 0;
    message.paymentProvider = object.paymentProvider ?? "";
    message.providerPaymentId = object.providerPaymentId ?? "";
    message.paidAt = object.paidAt ?? undefined;
    message.refundedAt = object.refundedAt ?? undefined;
    message.refundAmount = object.refundAmount ?? 0;
    message.refundReason = object.refundReason ?? undefined;
    message.failureReason = object.failureReason ?? undefined;
    message.failureCode = object.failureCode ?? undefined;
    message.metadataJson = object.metadataJson ?? undefined;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.paymentTransactions = object.paymentTransactions?.map((e) => PaymentTransaction.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBasePaymentTransaction(): PaymentTransaction {
  return {
    id: "",
    transactionType: 0,
    status: "",
    amount: 0,
    transactionId: undefined,
    requestData: undefined,
    responseData: undefined,
    errorMessage: undefined,
    receiptUrl: undefined,
    payment: undefined,
    createdAt: 0,
  };
}

export const PaymentTransaction: MessageFns<PaymentTransaction> = {
  encode(message: PaymentTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transactionType !== 0) {
      writer.uint32(16).int32(message.transactionType);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.amount !== 0) {
      writer.uint32(32).int64(message.amount);
    }
    if (message.transactionId !== undefined) {
      writer.uint32(42).string(message.transactionId);
    }
    if (message.requestData !== undefined) {
      writer.uint32(50).string(message.requestData);
    }
    if (message.responseData !== undefined) {
      writer.uint32(58).string(message.responseData);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(66).string(message.errorMessage);
    }
    if (message.receiptUrl !== undefined) {
      writer.uint32(74).string(message.receiptUrl);
    }
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(402).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requestData = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.responseData = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.receiptUrl = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transactionType: isSet(object.transactionType)
        ? paymentTransaction_TransactionTypeFromJSON(object.transactionType)
        : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : undefined,
      requestData: isSet(object.requestData) ? globalThis.String(object.requestData) : undefined,
      responseData: isSet(object.responseData) ? globalThis.String(object.responseData) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      receiptUrl: isSet(object.receiptUrl) ? globalThis.String(object.receiptUrl) : undefined,
      payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
    };
  },

  toJSON(message: PaymentTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = paymentTransaction_TransactionTypeToJSON(message.transactionType);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.transactionId !== undefined) {
      obj.transactionId = message.transactionId;
    }
    if (message.requestData !== undefined) {
      obj.requestData = message.requestData;
    }
    if (message.responseData !== undefined) {
      obj.responseData = message.responseData;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.receiptUrl !== undefined) {
      obj.receiptUrl = message.receiptUrl;
    }
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentTransaction>, I>>(base?: I): PaymentTransaction {
    return PaymentTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentTransaction>, I>>(object: I): PaymentTransaction {
    const message = createBasePaymentTransaction();
    message.id = object.id ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.status = object.status ?? "";
    message.amount = object.amount ?? 0;
    message.transactionId = object.transactionId ?? undefined;
    message.requestData = object.requestData ?? undefined;
    message.responseData = object.responseData ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.receiptUrl = object.receiptUrl ?? undefined;
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    return message;
  },
};

function createBaseStaff(): Staff {
  return { id: "", username: "", name: "", email: "", phone: undefined, isActive: false, createdAt: 0, updatedAt: 0 };
}

export const Staff: MessageFns<Staff> = {
  encode(message: Staff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.phone !== undefined) {
      writer.uint32(42).string(message.phone);
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    if (message.createdAt !== 0) {
      writer.uint32(784).uint64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(792).uint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Staff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 98: {
          if (tag !== 784) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 99: {
          if (tag !== 792) {
            break;
          }

          message.updatedAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Staff {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Staff): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Staff>, I>>(base?: I): Staff {
    return Staff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Staff>, I>>(object: I): Staff {
    const message = createBaseStaff();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.phone = object.phone ?? undefined;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
